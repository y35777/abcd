//
// AgentGen Standard v1.5  Copyright (C) Frank Fock, All rights reserved
// Not for use in a commercial environment
//

#include "./resource.h"
#include "snmp_alarm.h"
#include "alarm_snmp_agent.h"



/**
 *  generated by AgentGen 1.5 for AGENT++v3.4 
 * Tue Jul 01 15:47:29 CST 2003.
 */


//--AgentGen BEGIN=_INCLUDE
//--AgentGen END


/**
 *  queryType
 *
 */

queryType::queryType(const Oidx& id):
   MibLeaf(id, READCREATE, new OctetStr())
{
     m_nValLen = VALLEN;
    //--AgentGen BEGIN=queryType::queryType
    //--AgentGen END

}

queryType::~queryType()
{

    //--AgentGen BEGIN=queryType::~queryType
    //--AgentGen END
}

MibEntryPtr queryType::clone()
{
    MibEntryPtr other = new queryType(oid);
    ((queryType*)other)->replace_value(value->clone());
    ((queryType*)other)->set_reference_to_table(my_table);

    //--AgentGen BEGIN=queryType::clone
    //--AgentGen END
    return other;
}

void queryType::get_request(Request* req, int ind)
{

    //--AgentGen BEGIN=queryType::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}

int queryType::set(const Vbx& vb)
{
    if(alarmQueryEntry::s_pInstance->change_status())
    {
        int nRet = CAlarmSnmpAgent::Instance()->ModifyQueryCondition(
                                    alarmQueryEntry::s_pInstance->get_cur_index().c_str(),
                                    QUERY_TYPE,(char *)m_szCurVal);
        if(nRet)
        {
            STRING strErr = S_ALARM_MOD_QUERY_COND_FAIL;
            strErr       += strerror(errno);
            CAlarmSnmpAgent::Instance()->SendErrorInfo(strErr.c_str(),
                m_curPeerIp.cast_ipaddress().get_printable(),
                m_curPeerIp.cast_udpaddress().get_port());
            return SNMP_ERROR_BAD_VALUE;
        }
    }
    //--AgentGen BEGIN=queryType::set
    //--AgentGen END
    return MibLeaf::set(vb);
}

boolean queryType::value_ok(const Vbx& vb)
{
    vb.get_value((unsigned char *)m_szCurVal,m_nValLen);
    if(!alarmQueryEntry::type_valid(m_szCurVal,NULL))
    {
        if(m_curPeerIp.get_length() > 0)
        {
            CAlarmSnmpAgent::Instance()->SendErrorInfo("type condition is invalid",
                m_curPeerIp.cast_ipaddress().get_printable(),
                m_curPeerIp.cast_udpaddress().get_port());
        }

        return FALSE;
    }
    //--AgentGen BEGIN=queryType::value_ok
    //--AgentGen END
    return TRUE;
}

int queryType::prepare_set_request(Request* req, int& ind)
{
    CTarget *pTarget = req->get_address();
    m_curPeerIp = pTarget->get_address();
    
    int status;
    if ((status = MibLeaf::prepare_set_request(req, ind)) !=
        SNMP_ERROR_SUCCESS) return status;

    //--AgentGen BEGIN=queryType::prepare_set_request
    //--AgentGen END
    return SNMP_ERROR_SUCCESS;
}


//--AgentGen BEGIN=queryType
//--AgentGen END




/**
 *  queryRestoreFlag
 *
 */

queryRestoreFlag::queryRestoreFlag(const Oidx& id):
   MibLeaf(id, READCREATE, new OctetStr())
{
     m_nValLen = VALLEN;
    //--AgentGen BEGIN=queryRestoreFlag::queryRestoreFlag
    //--AgentGen END

}

queryRestoreFlag::~queryRestoreFlag()
{

    //--AgentGen BEGIN=queryRestoreFlag::~queryRestoreFlag
    //--AgentGen END
}

MibEntryPtr queryRestoreFlag::clone()
{
    MibEntryPtr other = new queryRestoreFlag(oid);
    ((queryRestoreFlag*)other)->replace_value(value->clone());
    ((queryRestoreFlag*)other)->set_reference_to_table(my_table);

    //--AgentGen BEGIN=queryRestoreFlag::clone
    //--AgentGen END
    return other;
}

void queryRestoreFlag::get_request(Request* req, int ind)
{

    //--AgentGen BEGIN=queryRestoreFlag::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}

int queryRestoreFlag::set(const Vbx& vb)
{
    if(alarmQueryEntry::s_pInstance->change_status())
    {
        int nRet = CAlarmSnmpAgent::Instance()->ModifyQueryCondition(
                                    alarmQueryEntry::s_pInstance->get_cur_index().c_str(),
                                    QUERY_RES_FLAG,m_szCurVal);
        if(nRet)
        {
            STRING strErr = S_ALARM_MOD_QUERY_COND_FAIL;
            strErr       += strerror(errno);
            CAlarmSnmpAgent::Instance()->SendErrorInfo(strErr.c_str(),
                m_curPeerIp.cast_ipaddress().get_printable(),
                m_curPeerIp.cast_udpaddress().get_port());
            return SNMP_ERROR_BAD_VALUE;
        }
    }
    //--AgentGen BEGIN=queryRestoreFlag::set
    //--AgentGen END
    return MibLeaf::set(vb);
}

boolean queryRestoreFlag::value_ok(const Vbx& vb)
{
    vb.get_value((unsigned char *)m_szCurVal,m_nValLen);
    if(!alarmQueryEntry::res_flg_valid(m_szCurVal,NULL))
    {
        if(m_curPeerIp.get_length() > 0)
        {
            CAlarmSnmpAgent::Instance()->SendErrorInfo("restore flag condition is invalid",
                m_curPeerIp.cast_ipaddress().get_printable(),
                m_curPeerIp.cast_udpaddress().get_port());
        }
        
        return FALSE;
    }
    //--AgentGen BEGIN=queryRestoreFlag::value_ok
    //--AgentGen END
    return TRUE;
}

int queryRestoreFlag::prepare_set_request(Request* req, int& ind)
{
    CTarget *pTarget = req->get_address();
    m_curPeerIp = pTarget->get_address();
    
    int status;
    if ((status = MibLeaf::prepare_set_request(req, ind)) !=
        SNMP_ERROR_SUCCESS) return status;

    //--AgentGen BEGIN=queryRestoreFlag::prepare_set_request
    //--AgentGen END
    return SNMP_ERROR_SUCCESS;
}


//--AgentGen BEGIN=queryRestoreFlag
//--AgentGen END




/**
 *  queryAckFlag
 *
 */

queryAckFlag::queryAckFlag(const Oidx& id):
   MibLeaf(id, READCREATE, new OctetStr())
{
     m_nValLen = VALLEN;
    //--AgentGen BEGIN=queryAckFlag::queryAckFlag
    //--AgentGen END
}

queryAckFlag::~queryAckFlag()
{

    //--AgentGen BEGIN=queryAckFlag::~queryAckFlag
    //--AgentGen END
}

MibEntryPtr queryAckFlag::clone()
{
    MibEntryPtr other = new queryAckFlag(oid);
    ((queryAckFlag*)other)->replace_value(value->clone());
    ((queryAckFlag*)other)->set_reference_to_table(my_table);

    //--AgentGen BEGIN=queryAckFlag::clone
    //--AgentGen END
    return other;
}

void queryAckFlag::get_request(Request* req, int ind)
{

    //--AgentGen BEGIN=queryAckFlag::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}

int queryAckFlag::set(const Vbx& vb)
{
    if(alarmQueryEntry::s_pInstance->change_status())
    {
        int nRet = CAlarmSnmpAgent::Instance()->ModifyQueryCondition(
                                    alarmQueryEntry::s_pInstance->get_cur_index().c_str(),
                                    QUERY_ACK_FLAG,m_szCurVal);
        if(nRet)
        {
            STRING strErr = S_ALARM_MOD_QUERY_COND_FAIL;
            strErr       += strerror(errno);
            CAlarmSnmpAgent::Instance()->SendErrorInfo(strErr.c_str(),
                                                   m_curPeerIp.cast_ipaddress().get_printable(),
                                                   m_curPeerIp.cast_udpaddress().get_port());
            return SNMP_ERROR_BAD_VALUE;
        }
    }
    //--AgentGen BEGIN=queryAckFlag::set
    //--AgentGen END
    return MibLeaf::set(vb);
}

boolean queryAckFlag::value_ok(const Vbx& vb)
{
    vb.get_value((unsigned char *)m_szCurVal,m_nValLen);
    if(!alarmQueryEntry::ack_flag_valid(m_szCurVal,NULL))
    {
        if(m_curPeerIp.get_length() > 0)
        {
            CAlarmSnmpAgent::Instance()->SendErrorInfo("ack flag condition is invalid",
                                               m_curPeerIp.cast_ipaddress().get_printable(),
                                               m_curPeerIp.cast_udpaddress().get_port());
        }
        return FALSE;
    }
    //--AgentGen BEGIN=queryAckFlag::value_ok
    //--AgentGen END
    return TRUE;
}

int queryAckFlag::prepare_set_request(Request* req, int& ind)
{
    CTarget *pTarget = req->get_address();
    m_curPeerIp = pTarget->get_address();
    
    int status;
    if ((status = MibLeaf::prepare_set_request(req, ind)) !=
        SNMP_ERROR_SUCCESS) return status;

    //--AgentGen BEGIN=queryAckFlag::prepare_set_request
    //--AgentGen END
    return SNMP_ERROR_SUCCESS;
}


//--AgentGen BEGIN=queryAckFlag
//--AgentGen END




/**
 *  queryModuleNumber
 *
 */

queryModuleNumber::queryModuleNumber(const Oidx& id):
   MibLeaf(id, READCREATE, new SnmpInt32())
{
    //--AgentGen BEGIN=queryModuleNumber::queryModuleNumber
    //--AgentGen END

}

queryModuleNumber::~queryModuleNumber()
{

    //--AgentGen BEGIN=queryModuleNumber::~queryModuleNumber
    //--AgentGen END
}

MibEntryPtr queryModuleNumber::clone()
{
    MibEntryPtr other = new queryModuleNumber(oid);
    ((queryModuleNumber*)other)->replace_value(value->clone());
    ((queryModuleNumber*)other)->set_reference_to_table(my_table);

    //--AgentGen BEGIN=queryModuleNumber::clone
    //--AgentGen END
    return other;
}

void queryModuleNumber::get_request(Request* req, int ind)
{

    //--AgentGen BEGIN=queryModuleNumber::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}

long queryModuleNumber::get_state()
{
    return (long)*((SnmpInt32*)value);
}

void queryModuleNumber::set_state(long l)
{
    *((SnmpInt32*)value) = l;
}

int queryModuleNumber::set(const Vbx& vb)
{
    if(alarmQueryEntry::s_pInstance->change_status())
    {
        int nRet = CAlarmSnmpAgent::Instance()->ModifyQueryCondition(
                                    alarmQueryEntry::s_pInstance->get_cur_index().c_str(),
                                    QUERY_MODULE_NUM,m_nVal);
        if(nRet)
        {
            STRING strErr = S_ALARM_MOD_QUERY_COND_FAIL;
            strErr       += strerror(errno);
            CAlarmSnmpAgent::Instance()->SendErrorInfo(strErr.c_str(),
                m_curPeerIp.cast_ipaddress().get_printable(),
                m_curPeerIp.cast_udpaddress().get_port());
            return SNMP_ERROR_BAD_VALUE;
        }
    }
    //--AgentGen BEGIN=queryModuleNumber::set
    //--AgentGen END
    return MibLeaf::set(vb);
}

boolean queryModuleNumber::value_ok(const Vbx& vb)
{
    long v;
    vb.get_value(v);
    if (!(((v >= 0) && (v <= 1))))
    {
        if(m_curPeerIp.get_length() > 0)
        {
            CAlarmSnmpAgent::Instance()->SendErrorInfo("module number condition is invalid",
                m_curPeerIp.cast_ipaddress().get_printable(),
                m_curPeerIp.cast_udpaddress().get_port());
        }
        return FALSE;
    }
    m_nVal = v;
    //--AgentGen BEGIN=queryModuleNumber::value_ok
    //--AgentGen END
    return TRUE;
}

int queryModuleNumber::prepare_set_request(Request* req, int& ind)
{
    CTarget *pTarget = req->get_address();
    m_curPeerIp = pTarget->get_address();
    
    int status;
    if ((status = MibLeaf::prepare_set_request(req, ind)) !=
        SNMP_ERROR_SUCCESS) return status;

    //--AgentGen BEGIN=queryModuleNumber::prepare_set_request
    //--AgentGen END
    return SNMP_ERROR_SUCCESS;
}


//--AgentGen BEGIN=queryModuleNumber
//--AgentGen END




/**
 *  queryCsnScope
 *
 */

queryCsnScope::queryCsnScope(const Oidx& id):
   MibLeaf(id, READCREATE, new OctetStr())
{
     m_nValLen = VALLEN;
    //--AgentGen BEGIN=queryCsnScope::queryCsnScope
    //--AgentGen END

}

queryCsnScope::~queryCsnScope()
{

    //--AgentGen BEGIN=queryCsnScope::~queryCsnScope
    //--AgentGen END
}

MibEntryPtr queryCsnScope::clone()
{
    MibEntryPtr other = new queryCsnScope(oid);
    ((queryCsnScope*)other)->replace_value(value->clone());
    ((queryCsnScope*)other)->set_reference_to_table(my_table);

    //--AgentGen BEGIN=queryCsnScope::clone
    //--AgentGen END
    return other;
}

void queryCsnScope::get_request(Request* req, int ind)
{

    //--AgentGen BEGIN=queryCsnScope::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}

int queryCsnScope::set(const Vbx& vb)
{
    if(alarmQueryEntry::s_pInstance->change_status())
    {
        int nRet = CAlarmSnmpAgent::Instance()->ModifyQueryCondition(
                                    alarmQueryEntry::s_pInstance->get_cur_index().c_str(),
                                    QUERY_CSN_SCOPE,m_szCurVal);
        if(nRet)
        {
            STRING strErr = S_ALARM_MOD_QUERY_COND_FAIL;
            strErr       += strerror(errno);
            CAlarmSnmpAgent::Instance()->SendErrorInfo(strErr.c_str(),
                m_curPeerIp.cast_ipaddress().get_printable(),
                m_curPeerIp.cast_udpaddress().get_port());
            return SNMP_ERROR_BAD_VALUE;
        }
    }
    //--AgentGen BEGIN=queryCsnScope::set
    //--AgentGen END
    return MibLeaf::set(vb);
}

boolean queryCsnScope::value_ok(const Vbx& vb)
{
    vb.get_value((unsigned char *)m_szCurVal,m_nValLen);
    if(!alarmQueryEntry::csn_scope_valid(m_szCurVal,NULL))
    {
        if(m_curPeerIp.get_length() > 0)
        {
            CAlarmSnmpAgent::Instance()->SendErrorInfo("csn scope condition is invalid",
                m_curPeerIp.cast_ipaddress().get_printable(),
                m_curPeerIp.cast_udpaddress().get_port());
        }
        return FALSE;
    }
    //--AgentGen BEGIN=queryCsnScope::value_ok
    //--AgentGen END
    return TRUE;
}

int queryCsnScope::prepare_set_request(Request* req, int& ind)
{
    CTarget *pTarget = req->get_address();
    m_curPeerIp = pTarget->get_address();
    
    int status;
    if ((status = MibLeaf::prepare_set_request(req, ind)) !=
        SNMP_ERROR_SUCCESS) return status;

    //--AgentGen BEGIN=queryCsnScope::prepare_set_request
    //--AgentGen END
    return SNMP_ERROR_SUCCESS;
}


//--AgentGen BEGIN=queryCsnScope
//--AgentGen END




/**
 *  queryIDScope
 *
 */

queryIDScope::queryIDScope(const Oidx& id):
   MibLeaf(id, READCREATE, new OctetStr())
{
     m_nValLen = VALLEN;
    //--AgentGen BEGIN=queryIDScope::queryIDScope
    //--AgentGen END

}

queryIDScope::~queryIDScope()
{

    //--AgentGen BEGIN=queryIDScope::~queryIDScope
    //--AgentGen END
}

MibEntryPtr queryIDScope::clone()
{
    MibEntryPtr other = new queryIDScope(oid);
    ((queryIDScope*)other)->replace_value(value->clone());
    ((queryIDScope*)other)->set_reference_to_table(my_table);

    //--AgentGen BEGIN=queryIDScope::clone
    //--AgentGen END
    return other;
}

void queryIDScope::get_request(Request* req, int ind)
{

    //--AgentGen BEGIN=queryIDScope::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}

int queryIDScope::set(const Vbx& vb)
{
    if(alarmQueryEntry::s_pInstance->change_status())
    {
        int nRet = CAlarmSnmpAgent::Instance()->ModifyQueryCondition(
                                    alarmQueryEntry::s_pInstance->get_cur_index().c_str(),
                                    QUERY_ID_SCOPE,m_szCurVal);
        if(nRet)
        {
            STRING strErr = S_ALARM_MOD_QUERY_COND_FAIL;
            strErr       += strerror(errno);
            CAlarmSnmpAgent::Instance()->SendErrorInfo(strErr.c_str(),
                m_curPeerIp.cast_ipaddress().get_printable(),
                m_curPeerIp.cast_udpaddress().get_port());
            return SNMP_ERROR_BAD_VALUE;
        }
    }
    //--AgentGen BEGIN=queryIDScope::set
    //--AgentGen END
    return MibLeaf::set(vb);
}

boolean queryIDScope::value_ok(const Vbx& vb)
{
    vb.get_value((unsigned char *)m_szCurVal,m_nValLen);
    if(!alarmQueryEntry::id_scope_valid(m_szCurVal,NULL))
    {
        if(m_curPeerIp.get_length() > 0)
        {
            CAlarmSnmpAgent::Instance()->SendErrorInfo("id scope condition is invalid",
                    m_curPeerIp.cast_ipaddress().get_printable(),
                    m_curPeerIp.cast_udpaddress().get_port());
        }
        return FALSE;
    }
    //--AgentGen BEGIN=queryIDScope::value_ok
    //--AgentGen END
    return TRUE;
}

int queryIDScope::prepare_set_request(Request* req, int& ind)
{
    CTarget *pTarget = req->get_address();
    m_curPeerIp = pTarget->get_address();
    
    int status;
    if ((status = MibLeaf::prepare_set_request(req, ind)) !=
        SNMP_ERROR_SUCCESS) return status;

    //--AgentGen BEGIN=queryIDScope::prepare_set_request
    //--AgentGen END
    return SNMP_ERROR_SUCCESS;
}


//--AgentGen BEGIN=queryIDScope
//--AgentGen END




/**
 *  queryLevel
 *
 */

queryLevel::queryLevel(const Oidx& id):
   MibLeaf(id, READCREATE, new OctetStr())
{
     m_nValLen = VALLEN;
    //--AgentGen BEGIN=queryLevel::queryLevel
    //--AgentGen END

}

queryLevel::~queryLevel()
{

    //--AgentGen BEGIN=queryLevel::~queryLevel
    //--AgentGen END
}

MibEntryPtr queryLevel::clone()
{
    MibEntryPtr other = new queryLevel(oid);
    ((queryLevel*)other)->replace_value(value->clone());
    ((queryLevel*)other)->set_reference_to_table(my_table);

    //--AgentGen BEGIN=queryLevel::clone
    //--AgentGen END
    return other;
}

void queryLevel::get_request(Request* req, int ind)
{

    //--AgentGen BEGIN=queryLevel::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}

int queryLevel::set(const Vbx& vb)
{
    if(alarmQueryEntry::s_pInstance->change_status())
    {
        int nRet = CAlarmSnmpAgent::Instance()->ModifyQueryCondition(
                                    alarmQueryEntry::s_pInstance->get_cur_index().c_str(),
                                    QUERY_LEVEL,m_szCurVal);
        if(nRet)
        {
            STRING strErr = S_ALARM_MOD_QUERY_COND_FAIL;
            strErr       += strerror(errno);
            CAlarmSnmpAgent::Instance()->SendErrorInfo(strErr.c_str(),
                m_curPeerIp.cast_ipaddress().get_printable(),
                m_curPeerIp.cast_udpaddress().get_port());
            return SNMP_ERROR_BAD_VALUE;
        }
    }
    //--AgentGen BEGIN=queryLevel::set
    //--AgentGen END
    return MibLeaf::set(vb);
}

boolean queryLevel::value_ok(const Vbx& vb)
{
    vb.get_value((unsigned char *)m_szCurVal,m_nValLen);
    if(!alarmQueryEntry::level_valid(m_szCurVal,NULL))
    {
        if(m_curPeerIp.get_length() > 0)
        {
            CAlarmSnmpAgent::Instance()->SendErrorInfo("level condition is invalid",
                m_curPeerIp.cast_ipaddress().get_printable(),
                m_curPeerIp.cast_udpaddress().get_port());
        }
        return FALSE;
    }
    //--AgentGen BEGIN=queryLevel::value_ok
    //--AgentGen END
    return TRUE;
}

int queryLevel::prepare_set_request(Request* req, int& ind)
{
    CTarget *pTarget = req->get_address();
    m_curPeerIp = pTarget->get_address();
    
    int status;
    if ((status = MibLeaf::prepare_set_request(req, ind)) !=
        SNMP_ERROR_SUCCESS) return status;

    //--AgentGen BEGIN=queryLevel::prepare_set_request
    //--AgentGen END
    return SNMP_ERROR_SUCCESS;
}


//--AgentGen BEGIN=queryLevel
//--AgentGen END




/**
 *  querySubsystemID
 *
 */

querySubsystemID::querySubsystemID(const Oidx& id):
   MibLeaf(id, READCREATE, new OctetStr())
{
     m_nValLen = VALLEN;
    //--AgentGen BEGIN=querySubsystemID::querySubsystemID
    //--AgentGen END

}

querySubsystemID::~querySubsystemID()
{

    //--AgentGen BEGIN=querySubsystemID::~querySubsystemID
    //--AgentGen END
}

MibEntryPtr querySubsystemID::clone()
{
    MibEntryPtr other = new querySubsystemID(oid);
    ((querySubsystemID*)other)->replace_value(value->clone());
    ((querySubsystemID*)other)->set_reference_to_table(my_table);

    //--AgentGen BEGIN=querySubsystemID::clone
    //--AgentGen END
    return other;
}

void querySubsystemID::get_request(Request* req, int ind)
{

    //--AgentGen BEGIN=querySubsystemID::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}

int querySubsystemID::set(const Vbx& vb)
{
    if(alarmQueryEntry::s_pInstance->change_status())
    {
        int nRet = CAlarmSnmpAgent::Instance()->ModifyQueryCondition(
                                    alarmQueryEntry::s_pInstance->get_cur_index().c_str(),
                                    QUERY_SUBSYS_ID,m_szCurVal);
        if(nRet)
        {
            STRING strErr = S_ALARM_MOD_QUERY_COND_FAIL;
            strErr       += strerror(errno);
            CAlarmSnmpAgent::Instance()->SendErrorInfo(strErr.c_str(),
                m_curPeerIp.cast_ipaddress().get_printable(),
                m_curPeerIp.cast_udpaddress().get_port());
            return SNMP_ERROR_BAD_VALUE;
        }
    }
    //--AgentGen BEGIN=querySubsystemID::set
    //--AgentGen END
    return MibLeaf::set(vb);
}

boolean querySubsystemID::value_ok(const Vbx& vb)
{
    vb.get_value((unsigned char *)m_szCurVal,m_nValLen);
    if(!alarmQueryEntry::sub_sys_valid(m_szCurVal,NULL))
    {
        if(m_curPeerIp.get_length() > 0)
        {
            CAlarmSnmpAgent::Instance()->SendErrorInfo("subsystem id condition is invalid",
                m_curPeerIp.cast_ipaddress().get_printable(),
                m_curPeerIp.cast_udpaddress().get_port());
        }
        return FALSE;
    }
    //--AgentGen BEGIN=querySubsystemID::value_ok
    //--AgentGen END
    return TRUE;
}

int querySubsystemID::prepare_set_request(Request* req, int& ind)
{
    CTarget *pTarget = req->get_address();
    m_curPeerIp = pTarget->get_address();
    
    int status;
    if ((status = MibLeaf::prepare_set_request(req, ind)) !=
        SNMP_ERROR_SUCCESS) return status;

    //--AgentGen BEGIN=querySubsystemID::prepare_set_request
    //--AgentGen END
    return SNMP_ERROR_SUCCESS;
}


//--AgentGen BEGIN=querySubsystemID
//--AgentGen END




/**
 *  queryDateScope
 *
 */

queryDateScope::queryDateScope(const Oidx& id):
   MibLeaf(id, READCREATE, new OctetStr())
{
    m_nValLen = VALLEN;
    //--AgentGen BEGIN=queryDateScope::queryDateScope
    //--AgentGen END

}

queryDateScope::~queryDateScope()
{

    //--AgentGen BEGIN=queryDateScope::~queryDateScope
    //--AgentGen END
}

MibEntryPtr queryDateScope::clone()
{
    MibEntryPtr other = new queryDateScope(oid);
    ((queryDateScope*)other)->replace_value(value->clone());
    ((queryDateScope*)other)->set_reference_to_table(my_table);

    //--AgentGen BEGIN=queryDateScope::clone
    //--AgentGen END
    return other;
}

void queryDateScope::get_request(Request* req, int ind)
{

    //--AgentGen BEGIN=queryDateScope::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}

int queryDateScope::set(const Vbx& vb)
{
    if(alarmQueryEntry::s_pInstance->change_status())
    {
        int nRet = CAlarmSnmpAgent::Instance()->ModifyQueryCondition(
                                    alarmQueryEntry::s_pInstance->get_cur_index().c_str(),
                                    QUERY_DATE_SCOPE,m_szCurVal);
        if(nRet)
        {
            STRING strErr = S_ALARM_MOD_QUERY_COND_FAIL;
            strErr       += strerror(errno);
            CAlarmSnmpAgent::Instance()->SendErrorInfo(strErr.c_str(),
                m_curPeerIp.cast_ipaddress().get_printable(),
                m_curPeerIp.cast_udpaddress().get_port());
            return SNMP_ERROR_BAD_VALUE;
        }
    }
    //--AgentGen BEGIN=queryDateScope::set
    //--AgentGen END
    return MibLeaf::set(vb);
}

boolean queryDateScope::value_ok(const Vbx& vb)
{
    vb.get_value((unsigned char *)m_szCurVal,m_nValLen);
    if(!alarmQueryEntry::date_scope_valid(m_szCurVal,NULL))
    {
        if(m_curPeerIp.get_length() > 0)
        {
            CAlarmSnmpAgent::Instance()->SendErrorInfo("date scope condition is invalid",
                m_curPeerIp.cast_ipaddress().get_printable(),
                m_curPeerIp.cast_udpaddress().get_port());
        }
        return FALSE;
    }
    //--AgentGen BEGIN=queryDateScope::value_ok
    //--AgentGen END
    return TRUE;
}

int queryDateScope::prepare_set_request(Request* req, int& ind)
{
    CTarget *pTarget = req->get_address();
    m_curPeerIp = pTarget->get_address();
    
    int status;
    if ((status = MibLeaf::prepare_set_request(req, ind)) !=
        SNMP_ERROR_SUCCESS) return status;

    //--AgentGen BEGIN=queryDateScope::prepare_set_request
    //--AgentGen END
    return SNMP_ERROR_SUCCESS;
}


//--AgentGen BEGIN=queryDateScope
//--AgentGen END




/**
 *  queryTimeScope
 *
 */

queryTimeScope::queryTimeScope(const Oidx& id):
   MibLeaf(id, READCREATE, new OctetStr())
{
     m_nValLen = VALLEN;
    //--AgentGen BEGIN=queryTimeScope::queryTimeScope
    //--AgentGen END

}

queryTimeScope::~queryTimeScope()
{

    //--AgentGen BEGIN=queryTimeScope::~queryTimeScope
    //--AgentGen END
}

MibEntryPtr queryTimeScope::clone()
{
    MibEntryPtr other = new queryTimeScope(oid);
    ((queryTimeScope*)other)->replace_value(value->clone());
    ((queryTimeScope*)other)->set_reference_to_table(my_table);

    //--AgentGen BEGIN=queryTimeScope::clone
    //--AgentGen END
    return other;
}

void queryTimeScope::get_request(Request* req, int ind)
{

    //--AgentGen BEGIN=queryTimeScope::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}

int queryTimeScope::set(const Vbx& vb)
{
    if(alarmQueryEntry::s_pInstance->change_status())
    {
        int nRet = CAlarmSnmpAgent::Instance()->ModifyQueryCondition(
                                    alarmQueryEntry::s_pInstance->get_cur_index().c_str(),
                                    QUERY_TIME_SCOPE,m_szCurVal);
        if(nRet)
        {
            STRING strErr = S_ALARM_MOD_QUERY_COND_FAIL;
            strErr       += strerror(errno);
            CAlarmSnmpAgent::Instance()->SendErrorInfo(strErr.c_str(),
                m_curPeerIp.cast_ipaddress().get_printable(),
                m_curPeerIp.cast_udpaddress().get_port());
            return SNMP_ERROR_BAD_VALUE;
        }
    }
    //--AgentGen BEGIN=queryTimeScope::set
    //--AgentGen END
    return MibLeaf::set(vb);
}

boolean queryTimeScope::value_ok(const Vbx& vb)
{
    vb.get_value((unsigned char *)m_szCurVal,m_nValLen);
    if(!alarmQueryEntry::time_scope_valid(m_szCurVal,NULL))
    {
        if(m_curPeerIp.get_length() > 0)
        {
            CAlarmSnmpAgent::Instance()->SendErrorInfo("time scope condition is invalid",
                m_curPeerIp.cast_ipaddress().get_printable(),
                m_curPeerIp.cast_udpaddress().get_port());
        }
        return FALSE;
    }
    //--AgentGen BEGIN=queryTimeScope::value_ok
    //--AgentGen END
    return TRUE;
}

int queryTimeScope::prepare_set_request(Request* req, int& ind)
{
    CTarget *pTarget = req->get_address();
    m_curPeerIp = pTarget->get_address();
    
    int status;
    if ((status = MibLeaf::prepare_set_request(req, ind)) !=
        SNMP_ERROR_SUCCESS) return status;

    //--AgentGen BEGIN=queryTimeScope::prepare_set_request
    //--AgentGen END
    return SNMP_ERROR_SUCCESS;
}


//--AgentGen BEGIN=queryTimeScope
//--AgentGen END




/**
 *  returnCsn
 *
 */

returnCsn::returnCsn(const Oidx& id):
   MibLeaf(id, READCREATE, new SnmpInt32(64), VMODE_DEFAULT)
{

    //--AgentGen BEGIN=returnCsn::returnCsn
    //--AgentGen END

}

returnCsn::~returnCsn()
{

    //--AgentGen BEGIN=returnCsn::~returnCsn
    //--AgentGen END
}

MibEntryPtr returnCsn::clone()
{
    MibEntryPtr other = new returnCsn(oid);
    ((returnCsn*)other)->replace_value(value->clone());
    ((returnCsn*)other)->set_reference_to_table(my_table);

    //--AgentGen BEGIN=returnCsn::clone
    //--AgentGen END
    return other;
}

void returnCsn::get_request(Request* req, int ind)
{

    //--AgentGen BEGIN=returnCsn::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}

long returnCsn::get_state()
{
    return (long)*((SnmpInt32*)value);
}

void returnCsn::set_state(long l)
{
    *((SnmpInt32*)value) = l;
}

int returnCsn::set(const Vbx& vb)
{
    if(alarmQueryEntry::s_pInstance->change_status())
    {
        int nRet = CAlarmSnmpAgent::Instance()->ModifyQueryCondition(
                                    alarmQueryEntry::s_pInstance->get_cur_index().c_str(),
                                    QUERY_RETURN_CNT,m_nVal);
        if(nRet)
        {
            STRING strErr = S_ALARM_MOD_QUERY_COND_FAIL;
            strErr       += strerror(errno);
            CAlarmSnmpAgent::Instance()->SendErrorInfo(strErr.c_str(),
                m_curPeerIp.cast_ipaddress().get_printable(),
                m_curPeerIp.cast_udpaddress().get_port());
            return SNMP_ERROR_BAD_VALUE;
        }
    }
    //--AgentGen BEGIN=returnCsn::set
    //--AgentGen END
    return MibLeaf::set(vb);
}

boolean returnCsn::value_ok(const Vbx& vb)
{
    vb.get_value(m_nVal);
    if(!alarmQueryEntry::return_csn_valid(m_nVal,NULL))
    {
        if(m_curPeerIp.get_length() > 0)
        {
            CAlarmSnmpAgent::Instance()->SendErrorInfo("return csn condition is invalid",
                m_curPeerIp.cast_ipaddress().get_printable(),
                m_curPeerIp.cast_udpaddress().get_port());
        }
        return FALSE;
    }
    //--AgentGen BEGIN=returnCsn::value_ok
    //--AgentGen END
    return TRUE;
}

int returnCsn::prepare_set_request(Request* req, int& ind)
{
    CTarget *pTarget = req->get_address();
    m_curPeerIp = pTarget->get_address();
    
    int status;
    if ((status = MibLeaf::prepare_set_request(req, ind)) !=
        SNMP_ERROR_SUCCESS) return status;

    //--AgentGen BEGIN=returnCsn::prepare_set_request
    //--AgentGen END
    return SNMP_ERROR_SUCCESS;
}


//--AgentGen BEGIN=returnCsn
//--AgentGen END




/**
 *  queryRowStatus
 *
 */

queryRowStatus::queryRowStatus(const Oidx& id):
   snmpRowStatus(id, READCREATE)
{

    //--AgentGen BEGIN=queryRowStatus::queryRowStatus
    //--AgentGen END

}

queryRowStatus::~queryRowStatus()
{

    //--AgentGen BEGIN=queryRowStatus::~queryRowStatus
    //--AgentGen END
}

MibEntryPtr queryRowStatus::clone()
{
    MibEntryPtr other = new queryRowStatus(oid);
    ((queryRowStatus*)other)->replace_value(value->clone());
    ((queryRowStatus*)other)->set_reference_to_table(my_table);

    //--AgentGen BEGIN=queryRowStatus::clone
    //--AgentGen END
    return other;
}

long queryRowStatus::get_state()
{
    return (long)*((SnmpInt32*)value);
}

void queryRowStatus::set_state(long l)
{
    *((SnmpInt32*)value) = l;
}

int queryRowStatus::set(const Vbx& vb)
{

    //--AgentGen BEGIN=queryRowStatus::set
    //--AgentGen END
    return snmpRowStatus::set(vb);
}

int queryRowStatus::prepare_set_request(Request* req, int& ind)
{
    int status;
    if ((status = snmpRowStatus::prepare_set_request(req, ind)) !=
        SNMP_ERROR_SUCCESS) return status;

    //--AgentGen BEGIN=queryRowStatus::prepare_set_request
    //--AgentGen END
    return SNMP_ERROR_SUCCESS;
}


//--AgentGen BEGIN=queryRowStatus
//--AgentGen END




/**
 *  alarmCsn
 *
 */

alarmCsn* alarmCsn::s_pInstance = NULL;

alarmCsn::alarmCsn():
   MibLeaf(oidAlarmCsn, NOACCESS, new SnmpInt32())
{
    // This leaf object is a singleton. In order to access it use
    // the static pointer alarmCsn::s_pInstance.
    s_pInstance = this;

    //--AgentGen BEGIN=alarmCsn::alarmCsn
    //--AgentGen END

}

alarmCsn::~alarmCsn()
{

    //--AgentGen BEGIN=alarmCsn::~alarmCsn
    //--AgentGen END
}

void alarmCsn::get_request(Request* req, int ind)
{

    //--AgentGen BEGIN=alarmCsn::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}

long alarmCsn::get_state()
{
    return (long)*((SnmpInt32*)value);
}

void alarmCsn::set_state(long l)
{
    *((SnmpInt32*)value) = l;
}


//--AgentGen BEGIN=alarmCsn
//--AgentGen END




/**
 *  alarmID
 *
 */

alarmID* alarmID::s_pInstance = NULL;

alarmID::alarmID():
   MibLeaf(oidAlarmID, NOACCESS, new SnmpInt32())
{
    // This leaf object is a singleton. In order to access it use
    // the static pointer alarmID::s_pInstance.
    s_pInstance = this;

    //--AgentGen BEGIN=alarmID::alarmID
    //--AgentGen END

}

alarmID::~alarmID()
{

    //--AgentGen BEGIN=alarmID::~alarmID
    //--AgentGen END
}

void alarmID::get_request(Request* req, int ind)
{

    //--AgentGen BEGIN=alarmID::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}

long alarmID::get_state()
{
    return (long)*((SnmpInt32*)value);
}

void alarmID::set_state(long l)
{
    *((SnmpInt32*)value) = l;
}


//--AgentGen BEGIN=alarmID
//--AgentGen END




/**
 *  alarmType
 *
 */

alarmType* alarmType::s_pInstance = NULL;

alarmType::alarmType():
   MibLeaf(oidAlarmType, NOACCESS, new OctetStr())
{
    // This leaf object is a singleton. In order to access it use
    // the static pointer alarmType::s_pInstance.
    s_pInstance = this;

    //--AgentGen BEGIN=alarmType::alarmType
    //--AgentGen END

}

alarmType::~alarmType()
{

    //--AgentGen BEGIN=alarmType::~alarmType
    //--AgentGen END
}

void alarmType::get_request(Request* req, int ind)
{

    //--AgentGen BEGIN=alarmType::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}


//--AgentGen BEGIN=alarmType
//--AgentGen END




/**
 *  alarmLevel
 *
 */

alarmLevel* alarmLevel::s_pInstance = NULL;

alarmLevel::alarmLevel():
   MibLeaf(oidAlarmLevel, NOACCESS, new OctetStr())
{
    // This leaf object is a singleton. In order to access it use
    // the static pointer alarmLevel::s_pInstance.
    s_pInstance = this;

    //--AgentGen BEGIN=alarmLevel::alarmLevel
    //--AgentGen END

}

alarmLevel::~alarmLevel()
{

    //--AgentGen BEGIN=alarmLevel::~alarmLevel
    //--AgentGen END
}

void alarmLevel::get_request(Request* req, int ind)
{

    //--AgentGen BEGIN=alarmLevel::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}


//--AgentGen BEGIN=alarmLevel
//--AgentGen END




/**
 *  alarmModuleNumber
 *
 */

alarmModuleNumber* alarmModuleNumber::s_pInstance = NULL;

alarmModuleNumber::alarmModuleNumber():
   MibLeaf(oidAlarmModuleNumber, NOACCESS, new SnmpInt32())
{
    // This leaf object is a singleton. In order to access it use
    // the static pointer alarmModuleNumber::s_pInstance.
    s_pInstance = this;

    //--AgentGen BEGIN=alarmModuleNumber::alarmModuleNumber
    //--AgentGen END

}

alarmModuleNumber::~alarmModuleNumber()
{

    //--AgentGen BEGIN=alarmModuleNumber::~alarmModuleNumber
    //--AgentGen END
}

void alarmModuleNumber::get_request(Request* req, int ind)
{

    //--AgentGen BEGIN=alarmModuleNumber::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}

long alarmModuleNumber::get_state()
{
    return (long)*((SnmpInt32*)value);
}

void alarmModuleNumber::set_state(long l)
{
    *((SnmpInt32*)value) = l;
}


//--AgentGen BEGIN=alarmModuleNumber
//--AgentGen END




/**
 *  functionID
 *
 */

functionID* functionID::s_pInstance = NULL;

functionID::functionID():
   MibLeaf(oidFunctionID, NOACCESS, new OctetStr())
{
    // This leaf object is a singleton. In order to access it use
    // the static pointer functionID::s_pInstance.
    s_pInstance = this;

    //--AgentGen BEGIN=functionID::functionID
    //--AgentGen END

}

functionID::~functionID()
{

    //--AgentGen BEGIN=functionID::~functionID
    //--AgentGen END
}

void functionID::get_request(Request* req, int ind)
{

    //--AgentGen BEGIN=functionID::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}


//--AgentGen BEGIN=functionID
//--AgentGen END




/**
 *  alarmSubsystemID
 *
 */

alarmSubsystemID* alarmSubsystemID::s_pInstance = NULL;

alarmSubsystemID::alarmSubsystemID():
   MibLeaf(oidAlarmSubsystemID, NOACCESS, new OctetStr())
{
    // This leaf object is a singleton. In order to access it use
    // the static pointer alarmSubsystemID::s_pInstance.
    s_pInstance = this;

    //--AgentGen BEGIN=alarmSubsystemID::alarmSubsystemID
    //--AgentGen END

}

alarmSubsystemID::~alarmSubsystemID()
{

    //--AgentGen BEGIN=alarmSubsystemID::~alarmSubsystemID
    //--AgentGen END
}

void alarmSubsystemID::get_request(Request* req, int ind)
{

    //--AgentGen BEGIN=alarmSubsystemID::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}


//--AgentGen BEGIN=alarmSubsystemID
//--AgentGen END




/**
 *  alarmDate
 *
 */

alarmDate* alarmDate::s_pInstance = NULL;

alarmDate::alarmDate():
   MibLeaf(oidAlarmDate, NOACCESS, new OctetStr())
{
    // This leaf object is a singleton. In order to access it use
    // the static pointer alarmDate::s_pInstance.
    s_pInstance = this;

    //--AgentGen BEGIN=alarmDate::alarmDate
    //--AgentGen END

}

alarmDate::~alarmDate()
{

    //--AgentGen BEGIN=alarmDate::~alarmDate
    //--AgentGen END
}

void alarmDate::get_request(Request* req, int ind)
{

    //--AgentGen BEGIN=alarmDate::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}


//--AgentGen BEGIN=alarmDate
//--AgentGen END




/**
 *  cpuPosition
 *
 */

cpuPosition* cpuPosition::s_pInstance = NULL;

cpuPosition::cpuPosition():
   MibLeaf(oidCpuPosition, NOACCESS, new SnmpInt32())
{
    // This leaf object is a singleton. In order to access it use
    // the static pointer cpuPosition::s_pInstance.
    s_pInstance = this;

    //--AgentGen BEGIN=cpuPosition::cpuPosition
    //--AgentGen END

}

cpuPosition::~cpuPosition()
{

    //--AgentGen BEGIN=cpuPosition::~cpuPosition
    //--AgentGen END
}

void cpuPosition::get_request(Request* req, int ind)
{

    //--AgentGen BEGIN=cpuPosition::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}

long cpuPosition::get_state()
{
    return (long)*((SnmpInt32*)value);
}

void cpuPosition::set_state(long l)
{
    *((SnmpInt32*)value) = l;
}


//--AgentGen BEGIN=cpuPosition
//--AgentGen END




/**
 *  procesID
 *
 */

procesID* procesID::s_pInstance = NULL;

procesID::procesID():
   MibLeaf(oidProcesID, NOACCESS, new SnmpInt32())
{
    // This leaf object is a singleton. In order to access it use
    // the static pointer procesID::s_pInstance.
    s_pInstance = this;

    //--AgentGen BEGIN=procesID::procesID
    //--AgentGen END

}

procesID::~procesID()
{

    //--AgentGen BEGIN=procesID::~procesID
    //--AgentGen END
}

void procesID::get_request(Request* req, int ind)
{

    //--AgentGen BEGIN=procesID::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}

long procesID::get_state()
{
    return (long)*((SnmpInt32*)value);
}

void procesID::set_state(long l)
{
    *((SnmpInt32*)value) = l;
}


//--AgentGen BEGIN=procesID
//--AgentGen END




/**
 *  alarmParameter
 *
 */

alarmParameter* alarmParameter::s_pInstance = NULL;

alarmParameter::alarmParameter():
   MibLeaf(oidAlarmParameter, NOACCESS, new OctetStr())
{
    // This leaf object is a singleton. In order to access it use
    // the static pointer alarmParameter::s_pInstance.
    s_pInstance = this;

    //--AgentGen BEGIN=alarmParameter::alarmParameter
    //--AgentGen END

}

alarmParameter::~alarmParameter()
{

    //--AgentGen BEGIN=alarmParameter::~alarmParameter
    //--AgentGen END
}

void alarmParameter::get_request(Request* req, int ind)
{

    //--AgentGen BEGIN=alarmParameter::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}


//--AgentGen BEGIN=alarmParameter
//--AgentGen END




/**
 *  alarmRestoreType
 *
 */

alarmRestoreType* alarmRestoreType::s_pInstance = NULL;

alarmRestoreType::alarmRestoreType():
   MibLeaf(oidAlarmRestoreType, NOACCESS, new OctetStr())
{
    // This leaf object is a singleton. In order to access it use
    // the static pointer alarmRestoreType::s_pInstance.
    s_pInstance = this;

    //--AgentGen BEGIN=alarmRestoreType::alarmRestoreType
    //--AgentGen END

}

alarmRestoreType::~alarmRestoreType()
{

    //--AgentGen BEGIN=alarmRestoreType::~alarmRestoreType
    //--AgentGen END
}

void alarmRestoreType::get_request(Request* req, int ind)
{

    //--AgentGen BEGIN=alarmRestoreType::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}


//--AgentGen BEGIN=alarmRestoreType
//--AgentGen END




/**
 *  restoreDate
 *
 */

restoreDate* restoreDate::s_pInstance = NULL;

restoreDate::restoreDate():
   MibLeaf(oidRestoreDate, NOACCESS, new OctetStr())
{
    // This leaf object is a singleton. In order to access it use
    // the static pointer restoreDate::s_pInstance.
    s_pInstance = this;

    //--AgentGen BEGIN=restoreDate::restoreDate
    //--AgentGen END

}

restoreDate::~restoreDate()
{

    //--AgentGen BEGIN=restoreDate::~restoreDate
    //--AgentGen END
}

void restoreDate::get_request(Request* req, int ind)
{

    //--AgentGen BEGIN=restoreDate::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}


//--AgentGen BEGIN=restoreDate
//--AgentGen END




/**
 *  acknowledgementOperator
 *
 */

acknowledgementOperator* acknowledgementOperator::s_pInstance = NULL;

acknowledgementOperator::acknowledgementOperator():
   MibLeaf(oidAcknowledgementOperator, NOACCESS, new OctetStr())
{
    // This leaf object is a singleton. In order to access it use
    // the static pointer acknowledgementOperator::s_pInstance.
    s_pInstance = this;

    //--AgentGen BEGIN=acknowledgementOperator::acknowledgementOperator
    //--AgentGen END

}

acknowledgementOperator::~acknowledgementOperator()
{

    //--AgentGen BEGIN=acknowledgementOperator::~acknowledgementOperator
    //--AgentGen END
}

void acknowledgementOperator::get_request(Request* req, int ind)
{

    //--AgentGen BEGIN=acknowledgementOperator::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}


//--AgentGen BEGIN=acknowledgementOperator
//--AgentGen END




/**
 *  acknowledgementDate
 *
 */

acknowledgementDate* acknowledgementDate::s_pInstance = NULL;

acknowledgementDate::acknowledgementDate():
   MibLeaf(oidAcknowledgementDate, NOACCESS, new OctetStr())
{
    // This leaf object is a singleton. In order to access it use
    // the static pointer acknowledgementDate::s_pInstance.
    s_pInstance = this;

    //--AgentGen BEGIN=acknowledgementDate::acknowledgementDate
    //--AgentGen END

}

acknowledgementDate::~acknowledgementDate()
{

    //--AgentGen BEGIN=acknowledgementDate::~acknowledgementDate
    //--AgentGen END
}

void acknowledgementDate::get_request(Request* req, int ind)
{

    //--AgentGen BEGIN=acknowledgementDate::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}


//--AgentGen BEGIN=acknowledgementDate
//--AgentGen END




/**
 *  queryAlarm
 *
 */

queryAlarm* queryAlarm::s_pInstance = NULL;

queryAlarm::queryAlarm():
   MibLeaf(oidQueryAlarm, READWRITE, new OctetStr())
{
    // This leaf object is a singleton. In order to access it use
    // the static pointer queryAlarm::s_pInstance.
    s_pInstance = this;

    //--AgentGen BEGIN=queryAlarm::queryAlarm
    //--AgentGen END

}

queryAlarm::~queryAlarm()
{

    //--AgentGen BEGIN=queryAlarm::~queryAlarm
    //--AgentGen END
}

void queryAlarm::get_request(Request* req, int ind)
{

    //--AgentGen BEGIN=queryAlarm::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}

int queryAlarm::set(const Vbx& vb)
{
    //得到Vb的值NMSName
    //在NMSTable中得到IP与Port
    unsigned char szIP[16];
    unsigned long nLen = 16;
    int nPort;

    Oidx oidRowIndex = Oidx::from_string(m_szNmsName);
    MibTableRow *pRow = nmsEntry::s_pInstance->find_index(oidRowIndex);
    if(pRow)
    {
        pRow->get_nth(0)->get_value().get_value(szIP,nLen);
        pRow->get_nth(1)->get_value().get_value(nPort);
    }
    //3) 在queryConditionTable中得到条件值
    SQueryStatus sQuery;
    if(m_pQueryRow)
    {
        unsigned char szTmp[VALLEN];
        nLen = VALLEN;
        //query type
        m_pQueryRow->get_nth(0)->get_value().get_value(szTmp,nLen);
        sQuery.strQueryType = (char *)szTmp;
        //queryRestoreFlag
        m_pQueryRow->get_nth(1)->get_value().get_value(szTmp,nLen);
        sQuery.strQueryRestoreFlag = (char *)szTmp;
        //queryAckFlag
        m_pQueryRow->get_nth(2)->get_value().get_value(szTmp,nLen);
        sQuery.strQueryAckFlag = (char *)szTmp;
        //queryModuleNumber
        m_pQueryRow->get_nth(3)->get_value().get_value(sQuery.nQueryModuleNumber);
        //queryCsnScope
        m_pQueryRow->get_nth(4)->get_value().get_value(szTmp,nLen);
        sQuery.strQueryCsnScope = (char *)szTmp;
        //queryIDScope
        m_pQueryRow->get_nth(5)->get_value().get_value(szTmp,nLen);
        sQuery.strQueryIDScope = (char *)szTmp;
        //queryLevel
        m_pQueryRow->get_nth(6)->get_value().get_value(szTmp,nLen);
        sQuery.strQueryLevel = (char *)szTmp;
        //querySubsystemID
        m_pQueryRow->get_nth(7)->get_value().get_value(szTmp,nLen);
        sQuery.strQuerySubsystemID = (char *)szTmp;
        //queryDateScope
        m_pQueryRow->get_nth(8)->get_value().get_value(szTmp,nLen);
        sQuery.strQueryDateScope = (char *)szTmp;
        //queryTimeScope
        m_pQueryRow->get_nth(9)->get_value().get_value(szTmp,nLen);
        sQuery.strQueryTimeScope = (char *)szTmp;
        //returnCsn
        m_pQueryRow->get_nth(10)->get_value().get_value(sQuery.nReturnCsn);
        //4) 将条件值组成SQueryCondtion结构
        SAlarmQueryCond sCond;
        memset(&sCond,0,sizeof(SAlarmQueryCond));
        alarmQueryEntry::condtion_valid(sQuery,&sCond);
        //5) 调用CAlarmSnmpAgent的queryAlarm接口
        CAlarmSnmpAgent::Instance()->QueryAlarm(sCond,(char *)szIP,nPort);
    }
    //--AgentGen BEGIN=queryAlarm::set
    //--AgentGen END
    return MibLeaf::set(vb);
}

boolean queryAlarm::value_ok(const Vbx& vb)
{
    //验证是否存在这个NMSName
    unsigned long nLen = VALLEN;
    vb.get_value((unsigned char *)m_szNmsName,nLen);
    
    Oidx oidRowIndex = Oidx::from_string(m_szNmsName);
    m_pQueryRow = alarmQueryEntry::s_pInstance->find_index(oidRowIndex);

    return (m_pQueryRow != NULL);
}

int queryAlarm::prepare_set_request(Request* req, int& ind)
{
    CTarget *pTarget = req->get_address();
    m_curPeerIp = pTarget->get_address();
    
    int status;
    if ((status = MibLeaf::prepare_set_request(req, ind)) !=
        SNMP_ERROR_SUCCESS) return status;

    //--AgentGen BEGIN=queryAlarm::prepare_set_request
    //--AgentGen END
    return SNMP_ERROR_SUCCESS;
}
//--AgentGen BEGIN=queryAlarm
//--AgentGen END




/**
 *  errnoInformation
 *
 */

errnoInformation* errnoInformation::s_pInstance = NULL;

errnoInformation::errnoInformation():
   MibLeaf(oidErrnoInformation, NOACCESS, new OctetStr())
{
    // This leaf object is a singleton. In order to access it use
    // the static pointer errnoInformation::s_pInstance.
    s_pInstance = this;

    //--AgentGen BEGIN=errnoInformation::errnoInformation
    //--AgentGen END

}

errnoInformation::~errnoInformation()
{

    //--AgentGen BEGIN=errnoInformation::~errnoInformation
    //--AgentGen END
}

void errnoInformation::get_request(Request* req, int ind)
{

    //--AgentGen BEGIN=errnoInformation::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}


//--AgentGen BEGIN=errnoInformation
//--AgentGen END




/**
 *  errorTrap
 *
 */

errorTrap::errorTrap(): NotificationOriginator()
{

    //--AgentGen BEGIN=errorTrap::errorTrap
    //--AgentGen END
}

errorTrap::~errorTrap()
{

    //--AgentGen BEGIN=errorTrap::~errorTrap
    //--AgentGen END
}

void errorTrap::generate(Vbx* vbs, int sz, const OctetStr& context)
{

    //--AgentGen BEGIN=errorTrap::generate
    //--AgentGen END
    if (sz < 1) {
        LOG_BEGIN(ERROR_LOG | 1);
        LOG("errorTrap: too few var binds (given) (expected)");
        LOG(sz);
        LOG(1);
        LOG_END;
        return;
    }
    if (!(vbs[0].get_oid().in_subtree_of("1.3.6.1.4.1.2011.2.9.31"))) {
        LOG_BEGIN(ERROR_LOG | 1);
        LOG("errorTrap: wrong var bind (no.) (given) (expected)");
        LOG(1l);
        LOG(vbs[0].get_printable_oid());
        LOG("1.3.6.1.4.1.2011.2.9.31");
        LOG_END;
        return;
    }
    NotificationOriginator::generate(vbs, sz, oidErrorTrap, "", context);
}


//--AgentGen BEGIN=errorTrap
//--AgentGen END


/**
 *  alarmTrap
 *
 */

alarmTrap::alarmTrap(): NotificationOriginator()
{

    //--AgentGen BEGIN=alarmTrap::alarmTrap
    //--AgentGen END
}

alarmTrap::~alarmTrap()
{

    //--AgentGen BEGIN=alarmTrap::~alarmTrap
    //--AgentGen END
}

void alarmTrap::generate(Vbx* vbs, int sz, const OctetStr& context)
{

    //--AgentGen BEGIN=alarmTrap::generate
    //--AgentGen END
    if (sz < 15) {
        LOG_BEGIN(ERROR_LOG | 1);
        LOG("alarmTrap: too few var binds (given) (expected)");
        LOG(sz);
        LOG(15);
        LOG_END;
        return;
    }
    if (!(vbs[0].get_oid().in_subtree_of("1.3.6.1.4.1.2011.2.9.7"))) {
        LOG_BEGIN(ERROR_LOG | 1);
        LOG("alarmTrap: wrong var bind (no.) (given) (expected)");
        LOG(1l);
        LOG(vbs[0].get_printable_oid());
        LOG("1.3.6.1.4.1.2011.2.9.7");
        LOG_END;
        return;
    }
    if (!(vbs[1].get_oid().in_subtree_of("1.3.6.1.4.1.2011.2.9.10"))) {
        LOG_BEGIN(ERROR_LOG | 1);
        LOG("alarmTrap: wrong var bind (no.) (given) (expected)");
        LOG(2l);
        LOG(vbs[1].get_printable_oid());
        LOG("1.3.6.1.4.1.2011.2.9.10");
        LOG_END;
        return;
    }
    if (!(vbs[2].get_oid().in_subtree_of("1.3.6.1.4.1.2011.2.9.11"))) {
        LOG_BEGIN(ERROR_LOG | 1);
        LOG("alarmTrap: wrong var bind (no.) (given) (expected)");
        LOG(3l);
        LOG(vbs[2].get_printable_oid());
        LOG("1.3.6.1.4.1.2011.2.9.11");
        LOG_END;
        return;
    }
    if (!(vbs[3].get_oid().in_subtree_of("1.3.6.1.4.1.2011.2.9.12"))) {
        LOG_BEGIN(ERROR_LOG | 1);
        LOG("alarmTrap: wrong var bind (no.) (given) (expected)");
        LOG(4l);
        LOG(vbs[3].get_printable_oid());
        LOG("1.3.6.1.4.1.2011.2.9.12");
        LOG_END;
        return;
    }
    if (!(vbs[4].get_oid().in_subtree_of("1.3.6.1.4.1.2011.2.9.16"))) {
        LOG_BEGIN(ERROR_LOG | 1);
        LOG("alarmTrap: wrong var bind (no.) (given) (expected)");
        LOG(5l);
        LOG(vbs[4].get_printable_oid());
        LOG("1.3.6.1.4.1.2011.2.9.16");
        LOG_END;
        return;
    }
    if (!(vbs[5].get_oid().in_subtree_of("1.3.6.1.4.1.2011.2.9.18"))) {
        LOG_BEGIN(ERROR_LOG | 1);
        LOG("alarmTrap: wrong var bind (no.) (given) (expected)");
        LOG(6l);
        LOG(vbs[5].get_printable_oid());
        LOG("1.3.6.1.4.1.2011.2.9.18");
        LOG_END;
        return;
    }
    if (!(vbs[6].get_oid().in_subtree_of("1.3.6.1.4.1.2011.2.9.17"))) {
        LOG_BEGIN(ERROR_LOG | 1);
        LOG("alarmTrap: wrong var bind (no.) (given) (expected)");
        LOG(7l);
        LOG(vbs[6].get_printable_oid());
        LOG("1.3.6.1.4.1.2011.2.9.17");
        LOG_END;
        return;
    }
    if (!(vbs[7].get_oid().in_subtree_of("1.3.6.1.4.1.2011.2.9.4"))) {
        LOG_BEGIN(ERROR_LOG | 1);
        LOG("alarmTrap: wrong var bind (no.) (given) (expected)");
        LOG(8l);
        LOG(vbs[7].get_printable_oid());
        LOG("1.3.6.1.4.1.2011.2.9.4");
        LOG_END;
        return;
    }
    if (!(vbs[8].get_oid().in_subtree_of("1.3.6.1.4.1.2011.2.9.15"))) {
        LOG_BEGIN(ERROR_LOG | 1);
        LOG("alarmTrap: wrong var bind (no.) (given) (expected)");
        LOG(9l);
        LOG(vbs[8].get_printable_oid());
        LOG("1.3.6.1.4.1.2011.2.9.15");
        LOG_END;
        return;
    }
    if (!(vbs[9].get_oid().in_subtree_of("1.3.6.1.4.1.2011.2.9.6"))) {
        LOG_BEGIN(ERROR_LOG | 1);
        LOG("alarmTrap: wrong var bind (no.) (given) (expected)");
        LOG(10l);
        LOG(vbs[9].get_printable_oid());
        LOG("1.3.6.1.4.1.2011.2.9.6");
        LOG_END;
        return;
    }
    if (!(vbs[10].get_oid().in_subtree_of("1.3.6.1.4.1.2011.2.9.2"))) {
        LOG_BEGIN(ERROR_LOG | 1);
        LOG("alarmTrap: wrong var bind (no.) (given) (expected)");
        LOG(11l);
        LOG(vbs[10].get_printable_oid());
        LOG("1.3.6.1.4.1.2011.2.9.2");
        LOG_END;
        return;
    }
    if (!(vbs[11].get_oid().in_subtree_of("1.3.6.1.4.1.2011.2.9.3"))) {
        LOG_BEGIN(ERROR_LOG | 1);
        LOG("alarmTrap: wrong var bind (no.) (given) (expected)");
        LOG(12l);
        LOG(vbs[11].get_printable_oid());
        LOG("1.3.6.1.4.1.2011.2.9.3");
        LOG_END;
        return;
    }
    if (!(vbs[12].get_oid().in_subtree_of("1.3.6.1.4.1.2011.2.9.5"))) {
        LOG_BEGIN(ERROR_LOG | 1);
        LOG("alarmTrap: wrong var bind (no.) (given) (expected)");
        LOG(13l);
        LOG(vbs[12].get_printable_oid());
        LOG("1.3.6.1.4.1.2011.2.9.5");
        LOG_END;
        return;
    }
    if (!(vbs[13].get_oid().in_subtree_of("1.3.6.1.4.1.2011.2.9.8"))) {
        LOG_BEGIN(ERROR_LOG | 1);
        LOG("alarmTrap: wrong var bind (no.) (given) (expected)");
        LOG(14l);
        LOG(vbs[13].get_printable_oid());
        LOG("1.3.6.1.4.1.2011.2.9.8");
        LOG_END;
        return;
    }
    if (!(vbs[14].get_oid().in_subtree_of("1.3.6.1.4.1.2011.2.9.9"))) {
        LOG_BEGIN(ERROR_LOG | 1);
        LOG("alarmTrap: wrong var bind (no.) (given) (expected)");
        LOG(15l);
        LOG(vbs[14].get_printable_oid());
        LOG("1.3.6.1.4.1.2011.2.9.9");
        LOG_END;
        return;
    }
    NotificationOriginator::generate(vbs, sz, oidAlarmTrap, "", context);
}


//--AgentGen BEGIN=alarmTrap
//--AgentGen END


/**
 *  nmsIP
 *
 */

nmsIP::nmsIP(const Oidx& id):
   MibLeaf(id, READCREATE, new OctetStr())
{
    m_nValLen = VALLEN;
    //--AgentGen BEGIN=nmsIP::nmsIP
    //--AgentGen END

}

nmsIP::~nmsIP()
{

    //--AgentGen BEGIN=nmsIP::~nmsIP
    //--AgentGen END
}

MibEntryPtr nmsIP::clone()
{
    MibEntryPtr other = new nmsIP(oid);
    ((nmsIP*)other)->replace_value(value->clone());
    ((nmsIP*)other)->set_reference_to_table(my_table);

    //--AgentGen BEGIN=nmsIP::clone
    //--AgentGen END
    return other;
}

void nmsIP::get_request(Request* req, int ind)
{

    //--AgentGen BEGIN=nmsIP::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}

int nmsIP::set(const Vbx& vb)
{
    if(nmsEntry::s_pInstance->change_status())
    {
        int nRet = CAlarmSnmpAgent::Instance()->ModifyNMSInfo(
                                    nmsEntry::s_pInstance->get_cur_index().c_str(),
                                    NMS_IP,(const char *)m_szCurVal);
        if(nRet)
        {
            STRING strErr = S_ALARM_MOD_NMS_IP_FAIL;
            strErr       += strerror(errno);
            CAlarmSnmpAgent::Instance()->SendErrorInfo(strErr.c_str(),
                m_curPeerIp.cast_ipaddress().get_printable(),
                m_curPeerIp.cast_udpaddress().get_port());
            return SNMP_ERROR_BAD_VALUE;
        }
    }
    //--AgentGen BEGIN=nmsIP::set
    //--AgentGen END
    return MibLeaf::set(vb);
}

boolean nmsIP::value_ok(const Vbx& vb)
{
    vb.get_value(m_szCurVal,m_nValLen);
    char *pTmp = (char *)m_szCurVal;
    GenAddress addr(pTmp);
    if(!addr.valid())
    {
        if(m_curPeerIp.get_length() > 0)
        {
            CAlarmSnmpAgent::Instance()->SendErrorInfo("nms address is invalid",
                m_curPeerIp.cast_ipaddress().get_printable(),
                m_curPeerIp.cast_udpaddress().get_port());
        }
        return FALSE;
    }

    //--AgentGen BEGIN=nmsIP::value_ok
    //--AgentGen END
    return TRUE;
}

int nmsIP::prepare_set_request(Request* req, int& ind)
{
    CTarget *pTarget = req->get_address();
    m_curPeerIp = pTarget->get_address();
    
    int status;
    if ((status = MibLeaf::prepare_set_request(req, ind)) !=
        SNMP_ERROR_SUCCESS) return status;

    //--AgentGen BEGIN=nmsIP::prepare_set_request
    //--AgentGen END
    return SNMP_ERROR_SUCCESS;
}


//--AgentGen BEGIN=nmsIP
//--AgentGen END




/**
 *  nmsPort
 *
 */

nmsPort::nmsPort(const Oidx& id):
   MibLeaf(id, READCREATE, new SnmpInt32())
{

    //--AgentGen BEGIN=nmsPort::nmsPort
    //--AgentGen END

}

nmsPort::~nmsPort()
{

    //--AgentGen BEGIN=nmsPort::~nmsPort
    //--AgentGen END
}

MibEntryPtr nmsPort::clone()
{
    MibEntryPtr other = new nmsPort(oid);
    ((nmsPort*)other)->replace_value(value->clone());
    ((nmsPort*)other)->set_reference_to_table(my_table);

    //--AgentGen BEGIN=nmsPort::clone
    //--AgentGen END
    return other;
}

void nmsPort::get_request(Request* req, int ind)
{

    //--AgentGen BEGIN=nmsPort::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}

long nmsPort::get_state()
{
    return (long)*((SnmpInt32*)value);
}

void nmsPort::set_state(long l)
{
    *((SnmpInt32*)value) = l;
}

int nmsPort::set(const Vbx& vb)
{
    if(nmsEntry::s_pInstance->change_status())
    {
        int nRet = CAlarmSnmpAgent::Instance()->ModifyNMSInfo(
                                    nmsEntry::s_pInstance->get_cur_index().c_str(),
                                    NMS_PORT,m_nVal);
        if(nRet)
        {
            STRING strErr = S_ALARM_MOD_NMS_PORT_FAIL;
            strErr       += strerror(errno);
            CAlarmSnmpAgent::Instance()->SendErrorInfo(strErr.c_str(),
                m_curPeerIp.cast_ipaddress().get_printable(),
                m_curPeerIp.cast_udpaddress().get_port());
            return SNMP_ERROR_BAD_VALUE;
        }
    }
    //--AgentGen BEGIN=nmsPort::set
    //--AgentGen END
    return MibLeaf::set(vb);
}

boolean nmsPort::value_ok(const Vbx& vb)
{
    vb.get_value(m_nVal);
    if(m_nVal < 0 || m_nVal > 65534)
    {
        if(m_curPeerIp.get_length() > 0)
        {
            CAlarmSnmpAgent::Instance()->SendErrorInfo("nms port is invalid",
                m_curPeerIp.cast_ipaddress().get_printable(),
                m_curPeerIp.cast_udpaddress().get_port());
        }
        return FALSE;
    }
    //--AgentGen BEGIN=nmsPort::value_ok
    //--AgentGen END
    return TRUE;
}

int nmsPort::prepare_set_request(Request* req, int& ind)
{
    CTarget *pTarget = req->get_address();
    m_curPeerIp = pTarget->get_address();
    
    int status;
    if ((status = MibLeaf::prepare_set_request(req, ind)) !=
        SNMP_ERROR_SUCCESS) return status;

    //--AgentGen BEGIN=nmsPort::prepare_set_request
    //--AgentGen END
    return SNMP_ERROR_SUCCESS;
}


//--AgentGen BEGIN=nmsPort
//--AgentGen END




/**
 *  nmsRowStatus
 *
 */

nmsRowStatus::nmsRowStatus(const Oidx& id):
   snmpRowStatus(id, READCREATE)
{

    //--AgentGen BEGIN=nmsRowStatus::nmsRowStatus
    //--AgentGen END

}

nmsRowStatus::~nmsRowStatus()
{

    //--AgentGen BEGIN=nmsRowStatus::~nmsRowStatus
    //--AgentGen END
}

MibEntryPtr nmsRowStatus::clone()
{
    MibEntryPtr other = new nmsRowStatus(oid);
    ((nmsRowStatus*)other)->replace_value(value->clone());
    ((nmsRowStatus*)other)->set_reference_to_table(my_table);

    //--AgentGen BEGIN=nmsRowStatus::clone
    //--AgentGen END
    return other;
}

long nmsRowStatus::get_state()
{
    return (long)*((SnmpInt32*)value);
}

void nmsRowStatus::set_state(long l)
{
    *((SnmpInt32*)value) = l;
}

int nmsRowStatus::set(const Vbx& vb)
{

    //--AgentGen BEGIN=nmsRowStatus::set
    //--AgentGen END
    return snmpRowStatus::set(vb);
}

int nmsRowStatus::prepare_set_request(Request* req, int& ind)
{
    int status;
    if ((status = snmpRowStatus::prepare_set_request(req, ind)) !=
        SNMP_ERROR_SUCCESS) return status;

    //--AgentGen BEGIN=nmsRowStatus::prepare_set_request
    //--AgentGen END
    return SNMP_ERROR_SUCCESS;
}


//--AgentGen BEGIN=nmsRowStatus
//--AgentGen END




/**
 *  alarmQueryEntry
 *
 */
STRING alarmQueryEntry::m_strError;
char alarmQueryEntry::m_szCatch[VALLEN];

alarmQueryEntry* alarmQueryEntry::s_pInstance = NULL;

const index_info indAlarmQueryEntry[1] = {
    { sNMP_SYNTAX_OCTETS, FALSE, 0, 128 } };

alarmQueryEntry::alarmQueryEntry():
   MibTable(oidAlarmQueryEntry, indAlarmQueryEntry, 1)
{
    // This table object is a singleton. In order to access it use
    // the static pointer alarmQueryEntry::s_pInstance.
    s_pInstance = this;

    add_col(new queryType(colQueryType));
    add_col(new queryRestoreFlag(colQueryRestoreFlag));
    add_col(new queryAckFlag(colQueryAckFlag));
    add_col(new queryModuleNumber(colQueryModuleNumber));
    add_col(new queryCsnScope(colQueryCsnScope));
    add_col(new queryIDScope(colQueryIDScope));
    add_col(new queryLevel(colQueryLevel));
    add_col(new querySubsystemID(colQuerySubsystemID));
    add_col(new queryDateScope(colQueryDateScope));
    add_col(new queryTimeScope(colQueryTimeScope));
    add_col(new returnCsn(colReturnCsn));
    add_col(new queryRowStatus(colQueryRowStatus));
    m_curIndex = "";
    m_nChangeStatus = 0;
    //--AgentGen BEGIN=alarmQueryEntry::alarmQueryEntry
    //--AgentGen END
}

alarmQueryEntry::~alarmQueryEntry()
{

    //--AgentGen BEGIN=alarmQueryEntry::~alarmQueryEntry
    //--AgentGen END
}

boolean alarmQueryEntry::ready_for_service(Vbx* pvbs, int sz)
{

    //--AgentGen BEGIN=alarmQueryEntry::ready_for_service
    //--AgentGen END
    return MibTable::ready_for_service(pvbs, sz);
}

void alarmQueryEntry::row_added(MibTableRow* row, const Oidx& index, MibTable* src)
{
    // The row 'row' with 'index' has been added to the table.

    //--AgentGen BEGIN=alarmQueryEntry::row_added
    //--AgentGen END
}

void alarmQueryEntry::row_delete(MibTableRow* row, const Oidx& index, MibTable* src)
{
    // The row 'row' with 'index' will be deleted.

    //--AgentGen BEGIN=alarmQueryEntry::row_delete
    //--AgentGen END
}

void alarmQueryEntry::row_init(MibTableRow* row, const Oidx& index, MibTable* src)
{
    // The row 'row' with 'index' has been intialized.

    //--AgentGen BEGIN=alarmQueryEntry::row_init
    //--AgentGen END
}

void alarmQueryEntry::row_activated(MibTableRow* row, const Oidx& index, MibTable* src)
{
    // The row 'row' with 'index' has been activated.

    //--AgentGen BEGIN=alarmQueryEntry::row_activated
    //--AgentGen END
}

void alarmQueryEntry::row_deactivated(MibTableRow* row, const Oidx& index, MibTable* src)
{
    // The row 'row' with 'index' has been deactivated.

    //--AgentGen BEGIN=alarmQueryEntry::row_deactivated
    //--AgentGen END
}



void alarmQueryEntry::set_row(MibTableRow* r, char* p0, char* p1, char* p2, long p3, char* p4, char* p5, char* p6, char* p7, char* p8, char* p9
        , long p10, long p11)
{
    r->get_nth(0)->replace_value(new OctetStr(p0));
    r->get_nth(1)->replace_value(new OctetStr(p1));
    r->get_nth(2)->replace_value(new OctetStr(p2));
    r->get_nth(3)->replace_value(new SnmpInt32(p3));
    r->get_nth(4)->replace_value(new OctetStr(p4));
    r->get_nth(5)->replace_value(new OctetStr(p5));
    r->get_nth(6)->replace_value(new OctetStr(p6));
    r->get_nth(7)->replace_value(new OctetStr(p7));
    r->get_nth(8)->replace_value(new OctetStr(p8));
    r->get_nth(9)->replace_value(new OctetStr(p9));
    r->get_nth(10)->replace_value(new SnmpInt32(p10));
    r->get_nth(11)->replace_value(new SnmpInt32(p11));
}

int alarmQueryEntry::commit_set_request(Request* req, int ind)
{
    //利用Request的get_oid取得Oid
    Oidx oidIndex = index(req->get_oid(ind));

    //获得IP地址
    CTarget *pTarget = req->get_address();
    GenAddress addr = pTarget->get_address();
    IpAddress ip_addr = addr.cast_ipaddress();
    UdpAddress udp_addr = addr.cast_udpaddress();

    //利用index函数从Oid中得到索引（这里是指NMSName），付给m_curIndex
    std::stringstream ss;
    char ch;
    for(int i = 1; i < oidIndex.len(); i++)
    {
        ch = oidIndex[i];
        ss << ch;
    }
    ss << '\0';
    m_curIndex = ss.str();


    /* 
     * 处理增加、删除、更改QueryCond请求。
     */
    int nRet = SNMP_ERROR_SUCCESS;
    int nReqSize = req->subrequests();
    if(nReqSize >= 12)
    {
        m_nChangeStatus = 0;
        MibTableRow *pRow = find_index(oidIndex);

        //取得rowStatus
        int iCmd = 0;
        req->get_value(ind).get_value(iCmd);

        switch(iCmd) 
        {
        //增加QueryCond
        case rowCreateAndGo:

            if(pRow == NULL)
            {
                //如果在NMS中不存在相关地址则不能增加
                MibTableRow *pNMSRow = nmsEntry::s_pInstance->find_index(oidIndex);
                if(pNMSRow == NULL)
                {
                    m_strError = S_ALARM_ADD_QUERY_COND_FAIL;
                    m_strError += S_ALARM_NMS_NOT_EXIST;
                    nRet = SNMP_ERROR_COMITFAIL;
                    break;
                }

                //将其他值和索引组成QueryCondition结构，
                //调用CAlarmSnmpAgent的AddQueryCondition接口
                unsigned char szTmp[128];
                unsigned long nLen = sizeof(szTmp);
                int nTmp;

                SQueryStatus sCond;
                req->get_value(1).get_value(szTmp, nLen);
                sCond.strQueryType = (char*)szTmp;

                req->get_value(2).get_value(szTmp, nLen);
                sCond.strQueryRestoreFlag = (char*)szTmp;

                req->get_value(3).get_value(szTmp, nLen);
                sCond.strQueryAckFlag = (char*)szTmp;

                req->get_value(4).get_value(nTmp);
                sCond.nQueryModuleNumber = nTmp;

                req->get_value(5).get_value(szTmp, nLen);
                sCond.strQueryCsnScope = (char*)szTmp;

                req->get_value(6).get_value(szTmp, nLen);
                sCond.strQueryIDScope = (char*)szTmp;

                req->get_value(7).get_value(szTmp, nLen);
                sCond.strQueryLevel = (char*)szTmp;

                req->get_value(8).get_value(szTmp, nLen);
                sCond.strQuerySubsystemID = (char*)szTmp;

                req->get_value(9).get_value(szTmp, nLen);
                sCond.strQueryDateScope = (char*)szTmp;

                req->get_value(10).get_value(szTmp, nLen);
                sCond.strQueryTimeScope = (char*)szTmp;

                req->get_value(11).get_value(nLen);
                sCond.nReturnCsn = nLen;

                if(CAlarmSnmpAgent::Instance()->AddQueryCondition(sCond,m_curIndex.c_str()))
                {
                    m_strError = S_ALARM_ADD_QUERY_COND_FAIL;
                    m_strError += strerror(errno);
                    nRet = SNMP_ERROR_COMITFAIL;
                }
            }
            else
            {
                m_strError = S_ALARM_ADD_QUERY_COND_FAIL;
                m_strError += S_ALARM_QUERY_COND_ALREADY_EXIST;
                nRet = SNMP_ERROR_COMITFAIL;

            }
            break;

        //删除QueryCond
        case rowDestroy:
            
            if(pRow != NULL)
            {
                if( ERR_SUCCESS != CAlarmSnmpAgent::Instance()->DelQueryCondition(m_curIndex.c_str()))
                {
                    STRING strErr = S_ALARM_DEL_QUERY_COND_FAIL;
                    strErr += strerror(errno);
                    nRet = SNMP_ERROR_COMITFAIL;
                }
            }
            else
            {
                m_strError = S_ALARM_DEL_QUERY_COND_FAIL;
                m_strError += S_ALARM_QUERY_COND_NOT_EXIST;
                nRet = SNMP_ERROR_COMITFAIL;
            }
            break;

        default:
            //设置将m_nChangeStatus=1
            m_nChangeStatus = 1;
        }
    }

    //有错误产生，则发送Trap
    if(nRet != SNMP_ERROR_SUCCESS)
    {
        CAlarmSnmpAgent::Instance()->SendErrorInfo(m_strError.c_str(),
                    ip_addr.get_printable(),
                    udp_addr.get_port());   

        return nRet;
    }
    
    return MibTable::commit_set_request(req, ind);
}

//对所有查询条件进行校验或转换
BOOL alarmQueryEntry::condtion_valid(SQueryStatus &cond, SAlarmQueryCond *pQueryCond)
{
    //告警类型校验或转换
    if(!type_valid(cond.strQueryType.c_str(), pQueryCond))
        return FALSE;

    //恢复标志校验或转换
    if(!res_flg_valid(cond.strQueryRestoreFlag.c_str(),pQueryCond))
        return FALSE;

    //确认标志校验或转换
    if(!ack_flag_valid(cond.strQueryAckFlag.c_str(), pQueryCond))
        return FALSE;

    //模块号校验或转换
    if(!mod_num_valid(cond.nQueryModuleNumber, pQueryCond))
        return FALSE;
    
    //流水号校验或转换
    if(!csn_scope_valid(cond.strQueryCsnScope.c_str(), pQueryCond))
        return FALSE;

    //告警编号校验或转换
    if(!id_scope_valid(cond.strQueryIDScope.c_str(), pQueryCond))
        return FALSE;

    //告警级别校验或转换
    if(!level_valid(cond.strQueryLevel.c_str(), pQueryCond))
        return FALSE;

    //网管分类校验或转换
    if(!sub_sys_valid(cond.strQuerySubsystemID.c_str(), pQueryCond))
        return FALSE;

    //日期校验或转换
    if(!date_scope_valid(cond.strQueryDateScope.c_str(), pQueryCond))
        return FALSE;
    
    //时间校验或转换
    if(!time_scope_valid(cond.strQueryTimeScope.c_str(),pQueryCond))
        return FALSE;
    
    //返回记录数校验或转换
    if(!return_csn_valid(cond.nReturnCsn, pQueryCond))
        return FALSE;


    return TRUE;
}

//告警类型校验或转换
BOOL alarmQueryEntry::type_valid(const char *szType, SAlarmQueryCond *pQueryCond)
{
    strncpy(m_szCatch, szType, VALLEN);
    m_szCatch[VALLEN - 1] = 0;

    //不限制条件
    StringLTrim(m_szCatch);
    if(m_szCatch[0] == '\0')
    {
        if(pQueryCond != NULL)
        {
            pQueryCond->nAlarmType = 0;
        }

        return TRUE;
    }

    //转换查询条件
    char *pToken = strtok(&m_szCatch[0],"&");
    while(pToken)
    {
        if(ACE_OS::strcasecmp(pToken,S_ALARM_AT_EVENT) == 0)
        {
            if(pQueryCond != NULL)
            {
                pQueryCond->nAlarmType = 2;
            }
        }
        else if(ACE_OS::strcasecmp(pToken,S_ALARM_AT_FAULT) == 0)
        {
            if(pQueryCond != NULL)
            {
                pQueryCond->nAlarmType = 1;
            }
        }
        else
        {
            m_strError = pToken;
            m_strError += " : ";
            m_strError += S_ALARM_QUERY_NON_RECOGNITION;
            return FALSE;
        }
        pToken = strtok(NULL,"&");
    }

    return TRUE;
}

//恢复标志校验或转换
BOOL alarmQueryEntry::res_flg_valid(const char *szResFlg, SAlarmQueryCond *pQueryCond)
{
    strncpy(m_szCatch, szResFlg, VALLEN);
    m_szCatch[VALLEN - 1] = 0;

    //不限制条件
    StringLTrim(m_szCatch);
    if(m_szCatch[0] == '\0')
    {
        if(pQueryCond != NULL)
        {
            pQueryCond->nResFlg[2] = 1;
        }

        return TRUE;
    }

    //转换查询条件
    char *pToken = strtok(&m_szCatch[0],"&");
    while(pToken)
    {
        if(ACE_OS::strcasecmp(pToken,S_ALARM_AT_RESTORE) == 0)
        {
            if(pQueryCond != NULL)
            {
                pQueryCond->nResFlg[0] = 1;
            }
        }
        else if(ACE_OS::strcasecmp(pToken,S_ALARM_NOT_RECOVER) == 0)
        {
            if(pQueryCond != NULL)
            {
                pQueryCond->nResFlg[1] = 1;
            }
        }
        else
        {
            m_strError = pToken;
            m_strError += " : ";
            m_strError += S_ALARM_QUERY_NON_RECOGNITION;
            return FALSE;
        }
        pToken = strtok(NULL,"&");
    }
    
    return TRUE;
}

//确认标志校验或转换
BOOL alarmQueryEntry::ack_flag_valid(const char *szAckFlg, SAlarmQueryCond *pQueryCond)
{
    strncpy(m_szCatch, szAckFlg, VALLEN);
    m_szCatch[VALLEN - 1] = '\0';

    //不限制条件
    StringLTrim(m_szCatch);
    if(m_szCatch[0] == '\0')
    {
        if(pQueryCond != NULL)
        {
            pQueryCond->nAckFlg[2] = 1;
        }

        return TRUE;
    }

    //转换查询条件
    char *pToken = strtok(&m_szCatch[0],"&");
    while(pToken)
    {
        if(ACE_OS::strcasecmp(pToken,S_ALARM_ACKVALUE) == 0)
        {
            if(pQueryCond != NULL)
            {
                pQueryCond->nAckFlg[0] = 1;
            }
        }
        else if(ACE_OS::strcasecmp(pToken,S_ALARM_NOACKVALUE) == 0)
        {
            if(pQueryCond != NULL)
            {
                pQueryCond->nAckFlg[1] = 1;
            }
        }
        else
        {
            m_strError = pToken;
            m_strError += " : ";
            m_strError += S_ALARM_QUERY_NON_RECOGNITION;
            return FALSE;
        }
        pToken = strtok(NULL,"&");
    }

    return TRUE;
}

//模块号校验或转换
BOOL alarmQueryEntry::mod_num_valid(int nModNum, SAlarmQueryCond *pQueryCond)
{
    if(nModNum != 0 && nModNum != 1)
    {
        m_strError = "module number";
        m_strError += " : ";
        m_strError += S_ALARM_QUERY_VAL_INVALID;
        return FALSE;
    }

    if(pQueryCond != NULL)
    {
        pQueryCond->nModNum = nModNum;
    }

    return TRUE;
}

//流水号校验或转换
BOOL alarmQueryEntry::csn_scope_valid(const char *szCsnScope, SAlarmQueryCond *pQueryCond)
{
    strncpy(m_szCatch, szCsnScope, VALLEN);
    m_szCatch[VALLEN - 1] = '\0';

    //不限制条件
    StringLTrim(m_szCatch);
    if(m_szCatch[0] == '\0')
    {
        if(pQueryCond != NULL)
        {
            pQueryCond->nStartCsn = 0;
            pQueryCond->nEndCsn = 0;
        }

        return TRUE;
    }
    
    //转换查询条件
    unsigned int uTmp = 0;
    char *pToken = strtok(&m_szCatch[0],"-~&");
    if(pToken)
    {
        //起始序列号
        uTmp = atoi(pToken);
        if( uTmp < 1)
        {
            m_strError = pToken;
            m_strError += " : ";
            m_strError += S_ALARM_QUERY_VAL_INVALID;
            return FALSE;
        }

        if(pQueryCond != NULL)
        {
            pQueryCond->nStartCsn = uTmp;
        }

        //结束序列号
        if((pToken = strtok(NULL,"-~&")))
        {
            uTmp = atoi(pToken);
            if( uTmp < 1)
            {
                m_strError = pToken;
                m_strError += " : ";
                m_strError += S_ALARM_QUERY_VAL_INVALID;
                return FALSE;
            }

            if(pQueryCond != NULL)
            {
                pQueryCond->nEndCsn = uTmp;
            }
        }
        else
        {
            m_strError = pToken;
            m_strError += " : ";
            m_strError += S_ALARM_QUERY_NON_RECOGNITION;
            return FALSE;
        }
    }   
    else
    {
        m_strError = pToken;
        m_strError += " : ";
        m_strError += S_ALARM_QUERY_NON_RECOGNITION;
        return FALSE;
    }

    return TRUE;
}

//告警编号校验或转换
BOOL alarmQueryEntry::id_scope_valid(const char *szIdScope, SAlarmQueryCond *pQueryCond)
{
    strncpy(m_szCatch,szIdScope,VALLEN);
    m_szCatch[VALLEN-1] = 0;

    //不限制条件
    StringLTrim(m_szCatch);
    if(m_szCatch[0] == '\0')
    {
        if(pQueryCond != NULL)
        {
            pQueryCond->nStartAlarmID = 0;
            pQueryCond->nEndAlarmID = 0;
        }

        return TRUE;
    }

    //转换查询条件
    int nTmp = 0;
    char *pToken = strtok(&m_szCatch[0],"-~&");
    if(pToken)
    {
        //起始告警ID
        nTmp = atoi(pToken);
        if( nTmp < 1)
        {
            m_strError = pToken;
            m_strError += " : ";
            m_strError += S_ALARM_QUERY_VAL_INVALID;
            return FALSE;
        }

        if(pQueryCond != NULL)
        {
            pQueryCond->nStartAlarmID = nTmp;
        }
        
        //结束告警ID
        if((pToken = strtok(NULL,"-~&")))
        {
            nTmp = atoi(pToken);
            if( nTmp < 1)
            {
                m_strError = pToken;
                m_strError += " : ";
                m_strError += S_ALARM_QUERY_VAL_INVALID;
                return FALSE;
            }
            if(pQueryCond != NULL)
            {
                pQueryCond->nEndAlarmID = nTmp;
            }
        }
        else
        {
            m_strError = pToken;
            m_strError += " : ";
            m_strError += S_ALARM_QUERY_NON_RECOGNITION;
            return FALSE;
        }
    }   
    else
    {
        m_strError = pToken;
        m_strError += " : ";
        m_strError += S_ALARM_QUERY_NON_RECOGNITION;
        return FALSE;
    }

    return TRUE;
}

//告警级别校验或转换
BOOL alarmQueryEntry::level_valid(const char *szLevel, SAlarmQueryCond *pQueryCond)
{
    strncpy(m_szCatch, szLevel, VALLEN);
    m_szCatch[VALLEN - 1] = '\0';

    //不限制条件
    StringLTrim(m_szCatch);
    if(m_szCatch[0] == '\0')
    {
        if(pQueryCond != NULL)
        {
            pQueryCond->nAlmLvl[4] = 1;
        }

        return TRUE;
    }

    //转换查询条件
    char *pToken = strtok(&m_szCatch[0],"&");
    while(pToken)
    {
        if(ACE_OS::strcasecmp(pToken,S_ALARM_AL_EMERGENCY) == 0)
        {
            if(pQueryCond != NULL)
            {
                pQueryCond->nAlmLvl[AL_EMERGENCY] = 1;
            }
        }
        else if(ACE_OS::strcasecmp(pToken,S_ALARM_AL_IMPORTANT) == 0)
        {
            if(pQueryCond != NULL)
            {
                pQueryCond->nAlmLvl[AL_IMPORTANT] = 1;
            }
        }
        else if(ACE_OS::strcasecmp(pToken,S_ALARM_AL_MINOR) == 0)
        {
            if(pQueryCond != NULL)
            {
                pQueryCond->nAlmLvl[AL_MINOR] = 1;
            }
        }
        else if(ACE_OS::strcasecmp(pToken,S_ALARM_AL_WARNING) == 0)
        {
            if(pQueryCond != NULL)
            {
                pQueryCond->nAlmLvl[AL_WARNING] = 1;
            }
        }
        else
        {
            m_strError = pToken;
            m_strError += " : ";
            m_strError += S_ALARM_QUERY_NON_RECOGNITION;
            return FALSE;
        }
        pToken = strtok(NULL,"&");
    }
    
    return TRUE;
}

//网管分类校验或转换
BOOL alarmQueryEntry::sub_sys_valid(const char *szSubSys, SAlarmQueryCond *pQueryCond)
{
    strncpy(m_szCatch,szSubSys,VALLEN);
    m_szCatch[VALLEN-1] = 0;

    //不限制条件
    StringLTrim(m_szCatch);
    if(m_szCatch[0] == '\0')
    {
        if(pQueryCond != NULL)
        {
            pQueryCond->nASS[10] = 1;
        }

        return TRUE;
    }

    //转换查询条件
    char *pToken = strtok(&m_szCatch[0],"&");
    while(pToken)
    {
        if(ACE_OS::strcasecmp(pToken,S_ALARM_AS_POWER_SYSTEM) == 0)
        {
            if(pQueryCond != NULL)
            {
                pQueryCond->nASS[AS_POWER_SYSTEM] = 1;
            }
        }
        else if(ACE_OS::strcasecmp(pToken,S_ALARM_AS_ENVIROMENT_SYSTEM) == 0)
        {
            if(pQueryCond != NULL)
            {
                pQueryCond->nASS[AS_ENVIROMENT_SYSTEM] = 1;
            }
        }
        else if(ACE_OS::strcasecmp(pToken,S_ALARM_AS_SIGNALING_SYSTEM) == 0)
        {
            if(pQueryCond != NULL)
            {
                pQueryCond->nASS[AS_SIGNALING_SYSTEM] = 1;
            }
        }
        else if(ACE_OS::strcasecmp(pToken,S_ALARM_AS_TRUNK_SYSTEM) == 0)
        {
            if(pQueryCond != NULL)
            {
                pQueryCond->nASS[AS_TRUNK_SYSTEM] = 1;
            }
        }
        else if(ACE_OS::strcasecmp(pToken,S_ALARM_AS_HARDWARE_SYSTEM) == 0)
        {
            if(pQueryCond != NULL)
            {
                pQueryCond->nASS[AS_HARDWARE_SYSTEM] = 1;
            }
        }
        else if(ACE_OS::strcasecmp(pToken,S_ALARM_AS_SOFTWARE_SYSTEM) == 0)
        {
            if(pQueryCond != NULL)
            {
                pQueryCond->nASS[AS_SOFTWARE_SYSTEM] = 1;
            }
        }
        else if(ACE_OS::strcasecmp(pToken,S_ALARM_AS_RUNNING_SYSTEM) == 0)
        {
            if(pQueryCond != NULL)
            {
                pQueryCond->nASS[AS_RUNNING_SYSTEM] = 1;
            }
        }
        else
        {
            m_strError = pToken;
            m_strError += " : ";
            m_strError += S_ALARM_QUERY_NON_RECOGNITION;
            return FALSE;
        }
        pToken = strtok(NULL,"&");
    }

    return TRUE;
}


//日期校验或转换
BOOL alarmQueryEntry::date_scope_valid(const char *szDateScope, SAlarmQueryCond *pQueryCond)
{
    strncpy(m_szCatch, szDateScope, VALLEN);
    m_szCatch[VALLEN - 1] = 0;

    //不限制条件
    StringLTrim(m_szCatch);
    if(m_szCatch[0] == '\0')
    {
        if(pQueryCond != NULL)
        {
            pQueryCond->StartDate.tm_year = 0;
            pQueryCond->StartDate.tm_mon = 0;
            pQueryCond->StartDate.tm_mday = 0;

            pQueryCond->EndDate.tm_year = 0;
            pQueryCond->EndDate.tm_mon = 0;
            pQueryCond->EndDate.tm_mday = 0;
        }

        return TRUE;
    }

    //分析起始时间:格式为 2003-06-07
    //或者 2003/07/07 或者 2003&06&07
    //但长度必须为10位
    if(strlen(szDateScope) < 21)
    {
        m_strError = szDateScope;
        m_strError += " : ";
        m_strError += S_ALARM_QUERY_LEN_INVALID;
        return FALSE;
    }
    
    //起始日期
    strncpy(m_szCatch, szDateScope, 11);
    m_szCatch[10] = 0;

    unsigned int uTmp = 0;
    char *pToken = strtok(&m_szCatch[0],"-/&"); 
    if(pToken)
    {
        //起始年
        uTmp = atoi(pToken);
        if( uTmp < 1978)
        {
            m_strError = pToken;
            m_strError += " : ";
            m_strError += S_ALARM_QUERY_VAL_INVALID;
            return FALSE;
        }
        if(pQueryCond != NULL)
        {
            pQueryCond->StartDate.tm_year = uTmp - 1900;
        }

        //起始月
        if((pToken = strtok(NULL,"-~&")))
        {
            uTmp = atoi(pToken);
            if( uTmp < 1 || uTmp > 12)
            {
                m_strError = pToken;
                m_strError += " : ";
                m_strError += S_ALARM_QUERY_VAL_INVALID;
                return FALSE;
            }
            if(pQueryCond != NULL)
            {
                pQueryCond->StartDate.tm_mon = uTmp - 1;
            }
        }
        else
        {
            m_strError = pToken;
            m_strError += " : ";
            m_strError += S_ALARM_QUERY_NON_RECOGNITION;
            return FALSE;
        }

        //起始日
        if((pToken = strtok(NULL,"-~&")))
        {
            uTmp = atoi(pToken);
            if( uTmp < 1 || uTmp > 31)
            {
                m_strError = pToken;
                m_strError += " : ";
                m_strError += S_ALARM_QUERY_VAL_INVALID;
                return FALSE;
            }
            if(pQueryCond != NULL)
            {
                pQueryCond->StartDate.tm_mday = uTmp;
            }
        }
        else
        {
            m_strError = pToken;
            m_strError += " : ";
            m_strError += S_ALARM_QUERY_NON_RECOGNITION;
            return FALSE;
        }
    }   
    else
    {
        m_strError = pToken;
        m_strError += " : ";
        m_strError += S_ALARM_QUERY_NON_RECOGNITION;
        return FALSE;
    }

    //分析结束日期
    strncpy(m_szCatch,&szDateScope[11],11);
    m_szCatch[10] = 0;
    pToken = strtok(&m_szCatch[0],"-/&"); 
    if(pToken)
    {
        //结束年
        uTmp = atoi(pToken);
        if( uTmp < 1978)
        {
            m_strError = pToken;
            m_strError += " : ";
            m_strError += S_ALARM_QUERY_VAL_INVALID;
            return FALSE;
        }
        if(pQueryCond != NULL)
        {
            pQueryCond->EndDate.tm_year = uTmp - 1900;
        }

        //结束月
        if((pToken = strtok(NULL,"-~&")))
        {
            uTmp = atoi(pToken);
            if( uTmp < 1 || uTmp > 12)
            {
                m_strError = pToken;
                m_strError += " : ";
                m_strError += S_ALARM_QUERY_VAL_INVALID;
                return FALSE;
            }
            if(pQueryCond != NULL)
            {
                pQueryCond->EndDate.tm_mon = uTmp - 1;
            }
        }
        else
        {
            m_strError = pToken;
            m_strError += " : ";
            m_strError += S_ALARM_QUERY_NON_RECOGNITION;
            return FALSE;
        }

        //结束日
        if((pToken = strtok(NULL,"-~&")))
        {
            uTmp = atoi(pToken);
            if( uTmp < 1 || uTmp > 31)
            {
                m_strError = pToken;
                m_strError += " : ";
                m_strError += S_ALARM_QUERY_VAL_INVALID;
                return FALSE;
            }
            if(pQueryCond != NULL)
            {
                pQueryCond->EndDate.tm_mday = uTmp;
            }
        }
        else
        {
            m_strError = pToken;
            m_strError += " : ";
            m_strError += S_ALARM_QUERY_NON_RECOGNITION;
            return FALSE;
        }
    }   
    else
    {
        m_strError = pToken;
        m_strError += " : ";
        m_strError += S_ALARM_QUERY_NON_RECOGNITION;
        return FALSE;
    }

    return TRUE;
}

//时间校验或转换
BOOL alarmQueryEntry::time_scope_valid(const char *szTimeScope,SAlarmQueryCond *pQueryCond)
{
    strncpy(m_szCatch, szTimeScope, VALLEN);
    m_szCatch[VALLEN - 1] = 0;

    //不限制条件
    StringLTrim(m_szCatch);
    if(m_szCatch[0] == '\0')
    {
        if(pQueryCond != NULL)
        {
            pQueryCond->StartDate.tm_hour = 0;
            pQueryCond->StartDate.tm_min = 0;
            pQueryCond->StartDate.tm_sec = 0;

            pQueryCond->EndDate.tm_hour = 0;
            pQueryCond->EndDate.tm_min = 0;
            pQueryCond->EndDate.tm_sec = 0;
        }

        return TRUE;
    }

    //分析起始时间:格式为 03:06:07
    //或者 03&07&07 或者 03-06-07
    //但长度必须为8位
    if(strlen(szTimeScope) < 17)
    {
        m_strError = szTimeScope;
        m_strError += " : ";
        m_strError += S_ALARM_QUERY_LEN_INVALID;
        return FALSE;
    }

    //分析起始时间
    strncpy(m_szCatch,szTimeScope,9);
    m_szCatch[8] = 0;
    unsigned int uTmp = 0;
    char *pToken = strtok(&m_szCatch[0],"-:&"); 
    if(pToken)
    {
        //起始时
        uTmp = atoi(pToken);
        if( uTmp > 23)
        {
            m_strError = pToken;
            m_strError += " : ";
            m_strError += S_ALARM_QUERY_VAL_INVALID;
            return FALSE;
        }
        if(pQueryCond != NULL)
        {
            pQueryCond->StartDate.tm_hour = uTmp;
        }

        //起始分
        if((pToken = strtok(NULL,"-:&")))
        {
            uTmp = atoi(pToken);
            if( uTmp > 59)
            {
                m_strError = pToken;
                m_strError += " : ";
                m_strError += S_ALARM_QUERY_VAL_INVALID;
                return FALSE;
            }
            if(pQueryCond != NULL)
            {
                pQueryCond->StartDate.tm_min = uTmp;
            }
        }
        else
        {
            m_strError = pToken;
            m_strError += " : ";
            m_strError += S_ALARM_QUERY_NON_RECOGNITION;
            return FALSE;
        }

         //起始秒
        if((pToken = strtok(NULL,"-:&")))
        {
            uTmp = atoi(pToken);
            if( uTmp > 59)
            {
                m_strError = pToken;
                m_strError += " : ";
                m_strError += S_ALARM_QUERY_VAL_INVALID;
                return FALSE;
            }
            if(pQueryCond != NULL)
            {
                pQueryCond->StartDate.tm_sec = uTmp;
            }
        }
        else
        {
            m_strError = pToken;
            m_strError += " : ";
            m_strError += S_ALARM_QUERY_NON_RECOGNITION;
            return FALSE;
        }
    }   
    else
    {
        m_strError = pToken;
        m_strError += " : ";
        m_strError += S_ALARM_QUERY_NON_RECOGNITION;
        return FALSE;
    }

    //分析结束时间
    strncpy(m_szCatch,&szTimeScope[9],9);
    m_szCatch[8] = 0;

    pToken = strtok(&m_szCatch[0],"-:&"); 
    if(pToken)
    {
        //结束时
        uTmp = atoi(pToken);
        if( uTmp > 23 )
        {
            m_strError = pToken;
            m_strError += " : ";
            m_strError += S_ALARM_QUERY_VAL_INVALID;
            return FALSE;
        }
        if(pQueryCond != NULL)
        {
            pQueryCond->EndDate.tm_hour = uTmp;
        }

        //结束分
        if((pToken = strtok(NULL,"-:&")))
        {
            uTmp = atoi(pToken);
            if( uTmp > 59)
            {
                m_strError = pToken;
                m_strError += " : ";
                m_strError += S_ALARM_QUERY_VAL_INVALID;
                return FALSE;
            }
            if(pQueryCond != NULL)
            {
                pQueryCond->EndDate.tm_min = uTmp;
            }
        }
        else
        {
            m_strError = pToken;
            m_strError += " : ";
            m_strError += S_ALARM_QUERY_NON_RECOGNITION;
            return FALSE;
        }

        //结束秒
        if((pToken = strtok(NULL,"-:&")))
        {
            uTmp = atoi(pToken);
            if( uTmp > 59)
            {
                m_strError = pToken;
                m_strError += " : ";
                m_strError += S_ALARM_QUERY_VAL_INVALID;
                return FALSE;
            }
            if(pQueryCond != NULL)
            {
                pQueryCond->EndDate.tm_sec = uTmp;
            }
        }
        else
        {
            m_strError = pToken;
            m_strError += " : ";
            m_strError += S_ALARM_QUERY_NON_RECOGNITION;
            return FALSE;
        }
    }   
    else
    {
        m_strError = pToken;
        m_strError += " : ";
        m_strError += S_ALARM_QUERY_NON_RECOGNITION;
        return FALSE;
    }

    return TRUE;
}

//返回记录数校验或转换
BOOL alarmQueryEntry::return_csn_valid(int nRetCsn,SAlarmQueryCond *pQueryCond)
{
    if(nRetCsn < 1 || nRetCsn > 500)
    {
        m_strError = "return count";
        m_strError += " : ";
        m_strError += S_ALARM_QUERY_VAL_INVALID;
    }

    if(pQueryCond != NULL)
    {
        pQueryCond->nRetCount = nRetCsn;
    }

    return TRUE;
}
//--AgentGen BEGIN=alarmQueryEntry
//--AgentGen END




/**
 *  nmsEntry
 *
 */

nmsEntry* nmsEntry::s_pInstance = NULL;

const index_info indNmsEntry[1] = {
    { sNMP_SYNTAX_OCTETS, FALSE, 0, 128 } };

nmsEntry::nmsEntry():
   MibTable(oidNmsEntry, indNmsEntry, 1)
{
    // This table object is a singleton. In order to access it use
    // the static pointer nmsEntry::s_pInstance.
    s_pInstance = this;

    add_col(new nmsIP(colNmsIP));
    add_col(new nmsPort(colNmsPort));
    add_col(new nmsRowStatus(colNmsRowStatus));

    //--AgentGen BEGIN=nmsEntry::nmsEntry
    //--AgentGen END
}

nmsEntry::~nmsEntry()
{

    //--AgentGen BEGIN=nmsEntry::~nmsEntry
    //--AgentGen END
}

boolean nmsEntry::ready_for_service(Vbx* pvbs, int sz)
{

    //--AgentGen BEGIN=nmsEntry::ready_for_service
    //--AgentGen END
    return MibTable::ready_for_service(pvbs, sz);
}

void nmsEntry::row_added(MibTableRow* row, const Oidx& index, MibTable* src)
{
    // The row 'row' with 'index' has been added to the table.

    //--AgentGen BEGIN=nmsEntry::row_added
    //--AgentGen END
}

void nmsEntry::row_delete(MibTableRow* row, const Oidx& index, MibTable* src)
{
    // The row 'row' with 'index' will be deleted.

    //--AgentGen BEGIN=nmsEntry::row_delete
    //--AgentGen END
}

void nmsEntry::row_init(MibTableRow* row, const Oidx& index, MibTable* src)
{
    // The row 'row' with 'index' has been intialized.

    //--AgentGen BEGIN=nmsEntry::row_init
    //--AgentGen END
}

void nmsEntry::row_activated(MibTableRow* row, const Oidx& index, MibTable* src)
{
    // The row 'row' with 'index' has been activated.

    //--AgentGen BEGIN=nmsEntry::row_activated
    //--AgentGen END
}

void nmsEntry::row_deactivated(MibTableRow* row, const Oidx& index, MibTable* src)
{
    // The row 'row' with 'index' has been deactivated.

    //--AgentGen BEGIN=nmsEntry::row_deactivated
    //--AgentGen END
}



void nmsEntry::set_row(MibTableRow* r, char* p0, long p1, long p2)
{
    r->get_nth(0)->replace_value(new OctetStr(p0));
    r->get_nth(1)->replace_value(new SnmpInt32(p1));
    r->get_nth(2)->replace_value(new SnmpInt32(p2));
}

int nmsEntry::get_nms_list(LIST<STRING> &nms_list)
{
    List<MibTableRow>  *pList = get_rows();
    MibTableRow *pRow = NULL;
    int nSize = pList->size();
    Oidx oidIndex;
    char ch;
    std::stringstream ss;
    int i = 0;
    for(; i < nSize; i++)
    {
        ss.clear();
        pRow = pList->getNth(i);
        oidIndex = pRow->get_index();
        for(i = 1; i < oidIndex.len(); i++)
        {
            ch = oidIndex[i];
            ss << ch;
        }
        ss << '\0';
        nms_list.push_back(ss.str());
    }
    return 0;
}

int nmsEntry::commit_set_request(Request* req, int ind)
{
    //利用Request的get_oid取得Oid
    Oidx oidIndex = index(req->get_oid(ind));

    //获得IP地址
    CTarget *pTarget = req->get_address();
    GenAddress addr = pTarget->get_address();
    IpAddress ip_addr = addr.cast_ipaddress();
    UdpAddress udp_addr = addr.cast_udpaddress();
    
    //利用index函数从Oid中得到索引（这里是指NMSName），付给m_curIndex
    std::stringstream ss;
    char ch;
    for(int i = 1; i < oidIndex.len(); i++)
    {
        ch = oidIndex[i];
        ss << ch;
    }
    ss << '\0';
    m_curIndex = ss.str();


    /* 
     * 处理增加、删除、更改NMS请求。
     */
    int nRet = SNMP_ERROR_SUCCESS;
    int nReqSize = req->subrequests();
    if(nReqSize >= 3)
    {
        m_nChangeStatus = 0;
        MibTableRow *pRow = find_index(oidIndex);

        //取得rowStatus
        int iCmd = 0;
        req->get_value(ind).get_value(iCmd);

        switch(iCmd) 
        {
        //增加NMS
        case rowCreateAndGo:

            if(pRow == NULL)
            {
                SNMSInfo sNms;
                sNms.strName = m_curIndex;
            
                unsigned char szIP[128];
                unsigned long nLen = sizeof(szIP);
                req->get_value(1).get_value(szIP, nLen);
                sNms.strNmsIP = (char*)szIP;

                req->get_value(2).get_value(sNms.nNmsPort);

                //增加一个NMS
                if(ERR_SUCCESS != CAlarmSnmpAgent::Instance()->AddNmsInfo(sNms))
                {
                    m_strError = S_ALARM_ADD_NMS_FAIL;
                    m_strError += strerror(errno);

                    nRet = SNMP_ERROR_COMITFAIL;
                }
            }
            else
            {
                m_strError = S_ALARM_ADD_NMS_FAIL;
                m_strError += S_ALARM_NMS_ALREADY_EXIST;
                nRet = SNMP_ERROR_COMITFAIL;
            }
            break;

        //删除NMS
        case rowDestroy:
            
            if(pRow != NULL)
            {
                if( ERR_SUCCESS != CAlarmSnmpAgent::Instance()->DeleteNMS(m_curIndex.c_str()))
                {
                    STRING strErr = S_ALARM_DEL_NMS_FAIL;
                    strErr += strerror(errno);
                    nRet = SNMP_ERROR_COMITFAIL;
                }
            }
            else
            {
                m_strError = S_ALARM_DEL_NMS_FAIL;
                m_strError += S_ALARM_NMS_NOT_EXIST;
                nRet = SNMP_ERROR_COMITFAIL;
            }
            break;

        default:
            //设置将m_nChangeStatus=1
            m_nChangeStatus = 1;
        }
    }

    //有错误产生，则发送Trap
    if(nRet != SNMP_ERROR_SUCCESS)
    {
        CAlarmSnmpAgent::Instance()->SendErrorInfo(m_strError.c_str(),
                    ip_addr.get_printable(),
                    udp_addr.get_port());   

        return nRet;
    }
    
    return MibTable::commit_set_request(req,ind);
}

//--AgentGen BEGIN=nmsEntry
//--AgentGen END




huawei_snmpalarm_mib::huawei_snmpalarm_mib(): MibGroup("1.3.6.1.4.1.2011", "alarmIdentity")
{
    add(new alarmQueryEntry());
    //add(new alarmCsn());
    //add(new alarmID());
    //add(new alarmType());
    //add(new alarmLevel());
    //add(new alarmModuleNumber());
    //add(new functionID());
    //add(new alarmSubsystemID());
    //add(new alarmDate());
    //add(new cpuPosition());
    //add(new procesID());
    //add(new alarmParameter());
    //add(new alarmRestoreType());
    //add(new restoreDate());
    //add(new acknowledgementOperator());
    //add(new acknowledgementDate());
    add(new queryAlarm());
    //add(new errnoInformation());
    add(new nmsEntry());
}


//--AgentGen BEGIN=huawei_snmpalarm_mib
//--AgentGen END



//--AgentGen BEGIN=_END
//--AgentGen END

